# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['zmq_tubes']

package_data = \
{'': ['*']}

install_requires = \
['pyzmq']

entry_points = \
{'console_scripts': ['zmqtube-monitor = zmq_tubes.monitoring:main']}

setup_kwargs = {
    'name': 'zmq-tubes',
    'version': '1.12.0',
    'description': 'Wrapper for ZMQ comunication.',
    'long_description': '[![PyPI](https://img.shields.io/pypi/v/zmq_tubes?color=green&style=plastic)](https://pypi.org/project/zmq-tubes/)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/zmq_tubes?style=plastic)\n![License](https://img.shields.io/github/license/calcite/zmq_tubes?style=plastic)\n# ZMQ Tubes\n\nZMQ Tubes is a managing system for ZMQ communication. \nIt can manage many ZMQ sockets by one interface. \nThe whole system is hierarchical, based on topics \n(look at [MQTT topics](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/)).\n\n## Classes\n- **TubeMessage** - This class represents a request/response message. \n  Some types of tubes require a response in this format.\n- **Tube** - This class wraps a ZMQ socket. \n  It represents a connection between client and server.\n- **TubeMonitor** - The class can sniff of the ZMQTube communication.\n- **TubeNode** - This represents an application interface for communication via tubes.\n\n\n## Asyncio / Threading\nThe library support bot method. Asyncio from Python 3.7.\n\n```python\nfrom zmq_tubes import TubeNode, Tube            # Asyncio classes\nfrom zmq_tubes.threads import TubeNode, Tube    # Threads classes\n```\n\n\n## Usage:\n\n### Node definitions in yml file \nWe can define all tubes for one TubeNode by yml file. \n\n```yaml\n# test.yml\ntubes:\n  - name: Client REQ\n    addr:  ipc:///tmp/req.pipe    \n    tube_type: REQ\n    topics:\n      - foo/#\n      - +/bar\n  \n  - name: Client PUB\n    addr:  ipc:///tmp/pub.pipe    \n    tube_type: PUB\n    topics:\n      - foo/pub/#\n\n  - name: Server ROUTER\n    addr:  ipc:///tmp/router.pipe    \n    tube_type: ROUTER\n    server: yes\n    sockopts:\n      LINGER: 0\n    topics:\n      - server/#\n```\n\n```python\nimport asyncio\nimport yaml\nfrom zmq_tubes import TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n  return request.create_response(\'response\')\n\n\nasync def run():\n  with open(\'test.yml\', \'r+\') as fd:\n    schema = yaml.safe_load(fd)\n  node = TubeNode(schema=schema)\n  node.register_handler(\'server/#\', handler)\n  async with node:\n      await node.publish(\'foo/pub/test\', \'message 1\')\n      print(await node.request(\'foo/xxx\', \'message 2\'))\n\nasyncio.run(run())\n```\n\n\n\n\n### Request / Response\nThis is a simple scenario, the server processes the requests serially.\n#### Server:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n  return \'answer\'\n  # or return request.create_response(\'response\')\n\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/req_resp.pipe\',\n  server=True,\n  tube_type=\'REP\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\nawait node.start()\n\n# output: \'question\'\n```\n\n#### Client:\n\n```python\nfrom zmq_tubes import Tube, TubeNode\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/req_resp.pipe\',\n  tube_type=\'REQ\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nresponse = await node.request(\'test/xxx\', \'question\')\nprint(response.payload)\n# output: \'answer\'\n```\n\n\n\n\n### Subscribe / Publisher\n#### Server:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/sub_pub.pipe\',\n  server=True,\n  tube_type=\'SUB\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\nawait node.start()\n# output: \'message\'\n```\n\n#### Client:\n\n```python\nfrom zmq_tubes import Tube, TubeNode\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/sub_pub.pipe\',\n  tube_type=\'PUB\'\n)\n# In the case of publishing, the first message is very often\n# lost. The workaround is to connect the tube manually as soon as possible.\ntube.connect()\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.publish(\'test/xxx\', \'message\')        \n```\n\n\n\n\n### Request / Router\nThe server is asynchronous. It means it is able to process \nmore requests at the same time.\n\n#### Server:\n\n```python\nimport asyncio\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n  if request.payload == \'wait\':\n    await asyncio.sleep(10)\n  return request.create_response(request.payload)\n\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/req_router.pipe\',\n  server=True,\n  tube_type=\'ROUTER\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\nawait node.start()\n# output: \'wait\'\n# output: \'message\'\n```\n\n#### Client:\n\n```python\nimport asyncio\nfrom zmq_tubes import Tube, TubeNode\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/req_router.pipe\',\n  tube_type=\'REQ\'\n)\n\n\nasync def task(node, text):\n  print(await node.request(\'test/xxx\', text))\n\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nasyncio.create_task(task(node, \'wait\'))\nasyncio.create_task(task(node, \'message\'))\n# output: \'message\'\n# output: \'wait\'\n```\n\n\n\n\n### Dealer / Response\nThe client is asynchronous. It means it is able to send \nmore requests at the same time.\n\n#### Server:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n  return \'response\'\n  # or return requset.create_response(\'response\')\n\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/dealer_resp.pipe\',\n  server=True,\n  tube_type=\'REP\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\nawait node.start()\n# output: \'message\'\n```\n\n#### Client:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/dealer_resp.pipe\',\n  tube_type=\'DEALER\'\n)\n\n\nasync def handler(response: TubeMessage):\n  print(response.payload)\n\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\n\nawait node.send(\'test/xxx\', \'message\')\n\n# output: \'response\'\n```\n\n\n\n### Dealer / Router\nThe client and server are asynchronous. It means it is able to send and process \nmore requests/responses at the same time.\n\n#### Server:\n\n```python\nimport asyncio\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\n\nasync def handler(request: TubeMessage):\n  print(request.payload)\n  if request.payload == \'wait\':\n    await asyncio.sleep(10)\n  return request.create_response(request.payload)\n\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/dealer_router.pipe\',\n  server=True,\n  tube_type=\'ROUTER\'\n)\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\nawait node.start()\n# output: \'wait\'\n# output: \'message\'\n```\n\n#### Client:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/dealer_router.pipe\',\n  tube_type=\'DEALER\'\n)\n\n\nasync def handler(response: TubeMessage):\n  print(response.payload)\n\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\n\nawait node.send(\'test/xxx\', \'wait\')\nawait node.send(\'test/xxx\', \'message\')\n\n# output: \'message\'\n# output: \'wait\'\n```\n\n\n\n### Dealer / Dealer\nThe client and server are asynchronous. It means it is able to send and process \nmore requests/responses at the same time.\n\n#### Server:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\ntube = Tube(\n  name=\'Server\',\n  addr=\'ipc:///tmp/dealer_dealer.pipe\',\n  server=True,\n  tube_type=\'DEALER\'\n)\n\n\nasync def handler(response: TubeMessage):\n  print(response.payload)\n\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\n\nawait node.send(\'test/xxx\', \'message from server\')\n# output: \'message from client\'\n```\n\n#### Client:\n\n```python\nfrom zmq_tubes import Tube, TubeNode, TubeMessage\n\ntube = Tube(\n  name=\'Client\',\n  addr=\'ipc:///tmp/dealer_dealer.pipe\',\n  tube_type=\'DEALER\'\n)\n\n\nasync def handler(response: TubeMessage):\n  print(response.payload)\n\n\nnode = TubeNode()\nnode.register_tube(tube, \'test/#\')\nnode.register_handler(\'test/#\', handler)\n\nawait node.send(\'test/xxx\', \'message from client\')\n# output: \'message from server\'\n```\n\n\n## Debugging / Monitoring\nWe can assign a monitor socket to our zmq tubes. By this monitor socket, we can sniff zmq communication or get a zmq tube\nconfiguration. \n```yaml\ntubes:\n  - name: ServerRouter\n    addr:  ipc:///tmp/router.pipe\n    monitor: ipc:///tmp/test.monitor \n    tube_type: ROUTER\n    server: yes    \n    topics:\n      - foo/#       \n```\nThis is example of a yaml definition. We can use the same monitor socket for more tubes in the same tubeNode.\nWhen we add the monitor attribute to our tube definition, the application automatically create a new socket monitor: \n`/tmp/test.monitor`. Your application works as a server side. The logs are sent to the socket only for the time, when the monitoring\ntool is running.\n\n### Monitoring tool\n\nAfter enabling of the monitoring in the application, we can use the monitoring tool for sniff. \n\n```shell\n# get the server tube configuration\n> zmqtube-monitor get_schema ipc:///tmp/display.monitor\n    tubes:\n      - addr: ipc:///tmp/router.pipe\n        monitor: ipc:///tmp/test.monitor \n        name: ServerRouter\n        server: \'yes\'\n        tube_type: ROUTER\n\n# the log tube communication. Logs will be saved to dump.rec as well. \n> zmqtube-monitor logs -d ./dump.rec ipc:///tmp/display.monitor\n 0.28026580810546875 ServerRouter < foo/test Request\n 0.0901789665222168 ServerRouter > foo/test Response\n\n# The format of output\n# <relative time> <tube name> <direction> <topic> <message>` \n```\n\n### Simulation of the client side\nWhen we have a dump file (e.g. `dump.rec`), we can simulate the communication with our app.\nThe first step is prepare the mock client schema file.\nFor this, We can get the tube node configuration from our application and after that edit it. \n```shell\n> zmqtube-monitor get_schema ipc:///tmp/display.monitor > mock_schema.yaml\n> vim mock_schema.yaml\n...   \n# Now, we have to update the file mock_schema.yaml. \n# We change configuration to the mock client configuration. \n# The names of the tubes must be the same as are in your app. \n# We can remove monitoring attribute and change server and \n# tube_type attributes. In this mock file, the topics are not \n# required, they are ignored. \n\n> cat mock_schema.yaml\ntubes:\n- addr: ipc:///tmp/router.pipe\n  name: ServerRouter\n  tube_type: REQ\n```\n\nNow, we can start the simulation of the client communication.\n```shell\n> zmqtube-monitor simulate mock_schema.yaml dump.rec\n```\nIf the response of our app is not the same as tool expects (the response saved in dump file), then \nthe monitoring tool warns us.  \nWe can modify speed of the simulation by the parameter `--speed`.\n\nIn the default configuration, is  the simulation run the same\nspeed as original communication (parameter `--speed=1`). \n\n| Speed | description |\n| :-: | :- |\n| 0 | no blocking simulation |\n| 0.5 | twice faster than original |\n| 1 | original speed |\n| 2 | twice slower than original |\n\n\n### Example of programming declaration of the monitoring.\n```python\nimport zmq\nfrom zmq_tubes.threads import Tube, TubeNode, TubeMessage, TubeMonitor\n\n\ndef handler(request: TubeMessage):\n  print(request.payload)\n  return request.create_response(\'response\')\n\nresp_tube = Tube(\n  name=\'REP\',\n  addr=\'ipc:///tmp/rep.pipe\',\n  server=\'yes\',\n  tube_type=zmq.REP\n)\n\nreq_tube = Tube(\n  name=\'REQ\',\n  addr=\'ipc:///tmp/rep.pipe\',  \n  tube_type=zmq.REQ\n)\n\nnode = TubeNode()\nnode.register_tube(resp_tube, f"foo/#")\nnode.register_tube(req_tube, f"foo/#")\nnode.register_handler(f"foo/#", handler)\n\nnode.register_monitor(resp_tube, TubeMonitor(addr=\'ipc:///tmp/test.monitor\'))\n  \nwith node:\n    print(node.request(\'foo/xxx\', \'message 2\'))\n\n```\n',
    'author': 'Martin Korbel',
    'author_email': 'mkorbel@alps.cz',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/calcite/zmq_tubes',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
