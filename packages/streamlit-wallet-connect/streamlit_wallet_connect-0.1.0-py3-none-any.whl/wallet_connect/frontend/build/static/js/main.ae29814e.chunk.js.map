{"version":3,"sources":["MyComponent.tsx","index.tsx"],"names":["getAccount","provider","ethers","Web3Provider","window","ethereum","request","method","send","on","accounts","signer","getSigner","getAddress","address","sendOcean","to_address","send_token_amount","contract_address","console","log","contractAddress","contractAbiFragment","name","type","inputs","constant","outputs","payable","contract","numberOfTokens","parseUnits","transfer","then","transferResult","dir","WalletConnect","state","walletAddress","transaction","isFocused","render","theme","props","style","borderStyling","primaryColor","border","outline","backgroundColor","color","borderRadius","message","args","onClick","onClicked","disabled","onFocus","_onFocus","onBlur","_onBlur","setState","Streamlit","setComponentValue","tx","StreamlitComponentBase","withStreamlitConnection","ReactDOM","StrictMode","MyComponent","document","getElementById"],"mappings":";slNAqBeA,I,2EAAf,+FAGEC,EAAW,IAAIC,IAAiBC,aAAaC,OAAOC,SAAU,OAHhE,SAKyBD,OAAOC,SAASC,QAAQ,CAC7CC,OAAQ,wBANZ,8BAQQN,EAASO,KAAK,sBAAuB,IAR7C,cASEJ,OAAOC,SAASI,GAAG,mBAAmB,SAAUC,OAGhDC,EAASV,EAASW,YAClBD,EAAS,IACTA,EAASV,EAASW,YAdpB,UAewBD,EAAOE,aAf/B,eAeQC,EAfR,yBAgBSA,GAhBT,6C,+BAmBeC,E,gFAAf,WAAyBC,EACDC,GADxB,sGAEwBC,EAFxB,+BAEmD,6CACjDC,QAAQC,IAAI,2BAENC,EAAkBH,EAClBI,EAAsB,CAC1B,CACEC,KAAM,WACNC,KAAM,WACNC,OAAQ,CACN,CACEF,KAAM,MACNC,KAAM,WAER,CACEA,KAAM,UACND,KAAM,YAGVG,UAAU,EACVC,QAAS,CACP,CACEJ,KAAM,GACNC,KAAM,SAGVI,SAAS,IAGbT,QAAQC,IAAI,sBACNnB,EAAW,IAAIC,IAAiBC,aAAaC,OAAOC,SAAU,OA/BtE,SAiCQJ,EAASO,KAAK,sBAAuB,IAjC7C,OAkCQG,EAASV,EAASW,YAEpBiB,EAAW,IAAI3B,IAAgBmB,EAAiBC,EAAqBX,GACzEQ,QAAQC,IAAI,oBAERU,EAAiB5B,IAAa6B,WAAWd,EAAmB,IAChEE,QAAQC,IAAR,0BAA+BU,IAC/BX,QAAQC,IAAI,qBAEZS,EAASG,SAAShB,EAAYc,GAAgBG,MAAK,SAACC,GAClDf,QAAQgB,IAAID,GACZf,QAAQC,IAAI,iBAEdD,QAAQC,IAAI,wCACZD,QAAQC,IAAIJ,GAhDd,6C,0BAiKMoB,E,4MACGC,MAAQ,CAAEC,cAAe,MAAOC,YAAa,GAAIC,WAAW,G,EAE5DC,OAAS,WAOd,IAAQC,EAAU,EAAKC,MAAfD,MACFE,EAA6B,GAInC,GAAIF,EAAO,CAGT,IAAMG,EAAa,oBACjB,EAAKR,MAAMG,UAAYE,EAAMI,aAAe,QAE9CF,EAAMG,OAASF,EACfD,EAAMI,QAAUH,EAChBD,EAAMK,gBAAkB,UACxBL,EAAMM,MAAQ,QACdN,EAAMO,aAAe,SAGvB,IAAMC,EAAU,EAAKT,MAAMU,KAAX,QAKhB,OACE,8BACE,4BACET,MAAOA,EACPU,QAAS,EAAKC,UACdC,SAAU,EAAKb,MAAMa,SACrBC,QAAS,EAAKC,SACdC,OAAQ,EAAKC,SAEZR,K,EAODG,U,sBAAY,yFACa,WAA3B,EAAKZ,MAAMU,KAAX,IADc,gCAEIrD,IAFJ,OAEZc,EAFY,OAGlB,EAAK+C,UACH,iBAAO,CAAEvB,cAAexB,MACxB,kBAAMgD,IAAUC,kBAAkB,EAAK1B,MAAMC,kBAL7B,0BAOoB,SAA3B,EAAKK,MAAMU,KAAX,IAPO,kCAQMtC,EAAU,EAAK4B,MAAMU,KAAX,WAA+B,EAAKV,MAAMU,KAAX,OAA2B,EAAKV,MAAMU,KAAX,kBAR1E,QAQVW,EARU,OAWhB,EAAKH,UACH,iBAAO,CAAEtB,YAAayB,MACtB,kBAAMF,IAAUC,kBAAkB,EAAK1B,MAAME,gBAb/B,4C,EAqBZmB,SAAW,WACjB,EAAKG,SAAS,CAAErB,WAAW,K,EAIrBoB,QAAU,WAChB,EAAKC,SAAS,CAAErB,WAAW,K,yBA5EHyB,KAqFbC,cAAwB9B,GC1RvC+B,IAAS1B,OACP,kBAAC,IAAM2B,WAAP,KACE,kBAACC,EAAD,OAEFC,SAASC,eAAe,W","file":"static/js/main.ae29814e.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\nimport * as ethers from \"ethers\"\n\ninterface State {\n  walletAddress: string\n  transaction: string\n  isFocused: boolean\n}\n\ndeclare global {\n  interface Window {\n    ethereum: any\n  }\n}\n\n\nasync function getAccount() {\n  var provider\n  var signer\n  provider = new ethers.providers.Web3Provider(window.ethereum, \"any\")\n  // Prompt user for account connections\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  await provider.send(\"eth_requestAccounts\", [])\n  window.ethereum.on('accountsChanged', function (accounts: any) {\n    // Time to reload your interface with accounts[0]!\n  });  \n  signer = provider.getSigner()\n  signer = \"0\"\n  signer = provider.getSigner()\n  const address = await signer.getAddress()\n  return address\n}\n\nasync function sendOcean(to_address: string,\n                        send_token_amount: string,\n                        contract_address: string = \"0x8967BCF84170c91B0d24D4302C2376283b0B3a07\") {\n  console.log(\"Sending OCEAN initiated\");\n\n  const contractAddress = contract_address;\n  const contractAbiFragment = [\n    {\n      name: \"transfer\",\n      type: \"function\",\n      inputs: [\n        {\n          name: \"_to\",\n          type: \"address\",\n        },\n        {\n          type: \"uint256\",\n          name: \"_tokens\",\n        },\n      ],\n      constant: false,\n      outputs: [\n        {\n          name: \"\",\n          type: \"bool\",\n        },\n      ],\n      payable: false,\n    },\n  ];\n  console.log(\"Parameters defined\");\n  const provider = new ethers.providers.Web3Provider(window.ethereum, \"any\");\n  // Prompt user for account connections\n  await provider.send(\"eth_requestAccounts\", []);\n  const signer = provider.getSigner();\n\n  let contract = new ethers.Contract(contractAddress, contractAbiFragment, signer);\n  console.log(\"Contract defined\");\n  // How many tokens?\n  let numberOfTokens = ethers.utils.parseUnits(send_token_amount, 18);\n  console.log(`numberOfTokens: ${numberOfTokens}`);\n  console.log(\"Ready to transfer\");\n  // Send tokens\n  contract.transfer(to_address, numberOfTokens).then((transferResult: any) => {\n    console.dir(transferResult);\n    console.log(\"sent token\");\n  });\n  console.log(\"Done: see address below on etherscan\");\n  console.log(to_address);\n}\n\nasync function send_token(\n  contract_address: string,\n  send_token_amount: string,\n  to_address: string\n) {\n  let provider = new ethers.providers.Web3Provider(window.ethereum, \"any\")\n  let walletSigner = provider.getSigner()\n  let send_account = await walletSigner.getAddress()\n  provider.getGasPrice().then((currentGasPrice: any) => {\n    let gas_price = ethers.utils.hexlify(parseInt(currentGasPrice))\n    console.log(`gas_price: ${gas_price}`)\n\n    // This is a simplified Contract Application Binary Interface (ABI) of an ERC-20 Token Contract.\n    let send_abi = [\n      {\n          'inputs': [{'internalType': 'address', 'name': 'account', 'type': 'address'}],\n          'name': 'balanceOf',\n          'outputs': [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}],\n          'stateMutability': 'view', 'type': 'function', 'constant': true\n      },\n      {\n          'inputs': [],\n          'name': 'decimals',\n          'outputs': [{'internalType': 'uint8', 'name': '', 'type': 'uint8'}],\n          'stateMutability': 'view', 'type': 'function', 'constant': true\n      },\n      {\n          'inputs': [],\n          'name': 'symbol',\n          'outputs': [{'internalType': 'string', 'name': '', 'type': 'string'}],\n          'stateMutability': 'view', 'type': 'function', 'constant': true\n      },\n      {\n          'inputs': [],\n          'name': 'totalSupply',\n          'outputs': [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}],\n          'stateMutability': 'view', 'type': 'function', 'constant': true\n      }\n  ]\n    if (contract_address) {\n      // general token send\n      let contract = new ethers.Contract(\n        contract_address,\n        send_abi,\n        walletSigner\n      )\n\n      // How many tokens?\n      let numberOfTokens = ethers.utils.parseUnits(send_token_amount, 18)\n      console.log(`numberOfTokens: ${numberOfTokens}`)\n\n      // Send tokens\n      contract.transfer(to_address, numberOfTokens).then((transferResult: any) => {\n        console.dir(transferResult)\n        alert(\"sent token\")\n      })\n    } // ether send\n    else {\n      const tx = {\n        from: send_account,\n        to: to_address,\n        value: ethers.utils.parseEther(send_token_amount),\n        nonce: provider.getTransactionCount(\n          send_account,\n          \"latest\"\n        ),\n        gasLimit: ethers.utils.hexlify(100000), // 100000 || gas_limit\n        gasPrice: gas_price,\n      }\n      console.dir(tx)\n      try {\n        walletSigner.sendTransaction(tx).then((transaction) => {\n          console.dir(transaction)\n          alert(\"Send finished!\")\n        })\n      } catch (error) {\n        alert(\"failed to send!!\")\n      }\n    }\n  })\n}\n\nasync function sendFixedPayment(tokenAmount: string, toAddress: string) {\n  console.log(\"Sending fixed payment\")\n  console.log(\"Sending payment of \" + tokenAmount + \" to \" + toAddress)\n  var ethersProvider = new ethers.providers.Web3Provider(window.ethereum, \"any\")\n  var signer = ethersProvider.getSigner()\n  const address = await signer.getAddress()\n  const gas_price = ethersProvider.getGasPrice()\n  const tx = {\n    from: address,\n    to: toAddress,\n    value: ethers.utils.parseEther(tokenAmount), // send_token_amount\n    nonce: ethersProvider.getTransactionCount(address, \"latest\"),\n    gasLimit: ethers.utils.hexlify(100000), // 100000 - gas_limit\n    gasPrice: gas_price,\n  }\n  console.log(\"Got here\")\n  signer.sendTransaction(tx).then((transaction) => {\n    console.dir(transaction)\n    alert(\"Send finished!\")\n  })\n\n  return \"Sent Transaction\"\n}\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass WalletConnect extends StreamlitComponentBase<State> {\n  public state = { walletAddress: \"not\", transaction: \"\", isFocused: false }\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n      const borderStyling = `0px solid ${\n        this.state.isFocused ? theme.primaryColor : \"gray\"\n      }`\n      style.border = borderStyling\n      style.outline = borderStyling\n      style.backgroundColor = \"#FF4B4B\"\n      style.color = \"white\"\n      style.borderRadius = \"0.2rem\"\n    }\n\n    const message = this.props.args[\"message\"]\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    return (\n      <span>\n        <button\n          style={style}\n          onClick={this.onClicked}\n          disabled={this.props.disabled}\n          onFocus={this._onFocus}\n          onBlur={this._onBlur}\n        >\n          {message}\n        </button>\n      </span>\n    )\n  }\n\n  /** Click handler for our \"Click Me!\" button. */\n  private onClicked = async (): Promise<void> => {\n    if (this.props.args[\"key\"] === \"wallet\") {\n    const address = await getAccount()\n    this.setState(\n      () => ({ walletAddress: address }),\n      () => Streamlit.setComponentValue(this.state.walletAddress)\n    )\n    } else if (this.props.args[\"key\"] === \"send\") {\n      const tx: any = await sendOcean(this.props.args[\"to_address\"], this.props.args[\"amount\"], this.props.args[\"contract_address\"])\n      // const tx: any = await send_token(this.props.args[\"contract_address\"], this.props.args[\"amount\"], this.props.args[\"to_address\"])\n      // const tx = await sendFixedPayment(String(this.props.args[\"amount\"]), this.props.args[\"to\"])\n      this.setState(\n        () => ({ transaction: tx }),\n        () => Streamlit.setComponentValue(this.state.transaction)\n      )\n    }\n    // Increment state.numClicks, and pass the new value back to\n    // Streamlit via `Streamlit.setComponentValue`.\n  }\n\n  /** Focus handler for our \"Click Me!\" button. */\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  /** Blur handler for our \"Click Me!\" button. */\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(WalletConnect)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport MyComponent from \"./MyComponent\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <MyComponent />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}