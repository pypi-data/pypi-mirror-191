import numpy as np
import threading
from .bounding_box import BoundingBox as BoundingBox
from .tools import is_jetson as is_jetson
from _typeshed import Incomplete
from edgeiq._constants import EDGEIQ_LOGS as EDGEIQ_LOGS
from enum import Enum
from typing import Any, Optional

nj: Incomplete

class CameraFailedToStart(RuntimeError):
    def __init__(self, cmd, backend, append: str = ...) -> None: ...

class CameraConnectionLost(RuntimeError):
    def __init__(self) -> None: ...

class _BaseVideoStream:
    def __init__(self, cmd, backend) -> None: ...
    def start(self): ...
    @property
    def fps(self): ...
    def read(self): ...
    def read_non_blocking(self): ...
    def stop(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback) -> None: ...

class WebcamVideoStream(_BaseVideoStream):
    def __init__(self, cam: int = ...) -> None: ...

class GStreamerVideoStream(_BaseVideoStream):
    def __init__(self, cam: int = ..., display_width: int = ..., display_height: int = ..., framerate: int = ...) -> None: ...

class GStreamerCustomVideoStream(_BaseVideoStream):
    def __init__(self, cmd: str) -> None: ...

class FrameRotation(Enum):
    ROTATE_NONE: int
    ROTATE_90: int
    ROTATE_180: int

class JetsonCameraMode(Enum):
    IMX219_3264x2468_21_0: int
    IMX219_3264x1848_28_1: int
    IMX219_1920x1080_30_2: int
    IMX219_1640x1232_30_3: int
    IMX477_4032x3040_30_0: int
    IMX477_1920x1080_60_1: int
    IMX477_2560x1440_40_3: int

class JetsonVideoStream(_BaseVideoStream):
    def __init__(self, cam: int = ..., rotation=..., camera_mode=..., display_width: int = ..., display_height: int = ...) -> None: ...

class IPVideoStream(_BaseVideoStream):
    def __init__(self, url) -> None: ...

class NoMoreFrames(RuntimeError):
    def __init__(self) -> None: ...

class _FileVideoStreamThread(threading.Thread):
    def __init__(self, stream: Any, queue_size: int, *args, **kwargs) -> None: ...
    @property
    def more(self) -> bool: ...
    def read(self) -> np.ndarray: ...
    def stop(self) -> None: ...
    def run(self) -> None: ...

class _RealtimeFileVideoStreamThread(threading.Thread):
    def __init__(self, stream: Any, fps: int, *args, **kwargs) -> None: ...
    @property
    def more(self) -> bool: ...
    def read(self) -> np.ndarray: ...
    def stop(self) -> None: ...
    def run(self) -> None: ...

class FileVideoStream:
    def __init__(self, path: str, queue_size: int = ..., play_realtime: bool = ..., fps: Optional[int] = ...) -> None: ...
    @property
    def fps(self) -> Optional[int]: ...
    def start(self): ...
    def read(self) -> np.ndarray: ...
    def more(self) -> bool: ...
    def stop(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback) -> None: ...
    def __del__(self) -> None: ...

class VideoWriter:
    output_path: Incomplete
    fps: Incomplete
    color: Incomplete
    fourcc: Incomplete
    h: Incomplete
    w: Incomplete
    writer: Incomplete
    chunk_duration: Incomplete
    chunk_count: int
    output_dir: Incomplete
    base_filename: Incomplete
    video_extension: Incomplete
    def __init__(self, output_path: str = ..., fps: int = ..., color: bool = ..., codec: str = ..., chunk_duration_s: Incomplete | None = ...) -> None: ...
    def __del__(self) -> None: ...
    def write_frame(self, frame) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback) -> None: ...

class EventVideoWriterState(Enum):
    IDLE: str
    RECORDING: str
    POST_ROLL: str

class _EventVideoWriterThread(threading.Thread):
    def __init__(self, output_path, fps, color, codec, queue, callback_function: Incomplete | None = ..., callback_args=..., *args, **kwargs) -> None: ...
    def run(self) -> None: ...

class EventVideoWriter:
    def __init__(self, pre_roll: int = ..., post_roll: int = ..., fps: int = ..., color: bool = ..., codec: str = ...) -> None: ...
    @property
    def state(self): ...
    def update(self, frame) -> None: ...
    def start_event(self, output_path, callback_function: Incomplete | None = ..., callback_args=...) -> None: ...
    def finish_event(self) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback) -> None: ...

class GStreamerCustomVideoWriter:
    def __init__(self, cmd: str, fps: int = ..., color: bool = ...) -> None: ...
    def write_frame(self, frame) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback) -> None: ...

def translate(image, x, y): ...
def rotate(image, angle): ...
def resize(image: np.ndarray, width: int = ..., height: int = ..., keep_scale: bool = ..., inter=...) -> np.ndarray: ...
def convert_to_jpg(image: np.ndarray, jpg_quality) -> bytes: ...
def list_images(base_path, contains: Incomplete | None = ...): ...
def list_files(base_path, valid_exts=..., contains: Incomplete | None = ...): ...
def markup_image(image, predictions, show_labels: bool = ..., show_confidences: bool = ..., colors: Incomplete | None = ..., line_thickness: int = ..., font_size: float = ..., font_thickness: int = ...): ...
def transparent_overlay_boxes(image, predictions, alpha: float = ..., colors: Incomplete | None = ..., show_labels: bool = ..., show_confidences: bool = ...): ...
def filter_predictions_by_label(predictions, label_list): ...
def filter_predictions_by_area(predictions, min_area_thresh): ...
def pad_to_aspect_ratio(image, a_ratio): ...
def cutout_image(image, box): ...
def blur_objects(image, predictions): ...
def blend_images(foreground_image, background_image, alpha): ...
def overlay_image(foreground_image, background_image, foreground_mask): ...
def perform_histogram_equalization(image, color_space: str = ..., adaptive: bool = ..., clip_limit: float = ..., tile_grid_size=...): ...
def perform_gamma_correction(image, gamma_value: float = ..., color: bool = ...): ...
