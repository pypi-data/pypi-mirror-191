# AUTOGENERATED! DO NOT EDIT! File to edit: ../../06b_sampler.base.ipynb.

# %% auto 0
__all__ = ['tolists', 'lens', 'maxlen', 'pad', 'tomatrix', 'err_probs_tomatrix', 'sort_by_list', 'subset_occurence',
           'all_subsets', 'protocol_all_subsets', 'protocol_subset_occurence', 'Sampler']

# %% ../../06b_sampler.base.ipynb 3
from .tree import CountTree, Variable, Constant

from ..callbacks import CallbackList
from tqdm.auto import tqdm
import itertools as it
import numpy as np
import qsample.math as math
from ..noise import E0
import dill as pickle

from collections.abc import Iterable

# %% ../../06b_sampler.base.ipynb 5
tolists = lambda l: [e if isinstance(e,Iterable) else [e] for e in l]
lens = lambda list_of_lists: list(map(len,list_of_lists))
maxlen = lambda list_of_lists: max(lens(list_of_lists))
pad = lambda l,targ_len: np.append(l, [l[-1]] * (targ_len - len(l)))

def tomatrix(mixed_list):
    list_of_lists = tolists(mixed_list)
    return [pad(e,maxlen(list_of_lists)) for e in list_of_lists]

def err_probs_tomatrix(err_probs: dict, groups: list) -> np.ndarray:
    err_probs = sort_by_list(err_probs, groups)
    return np.array(tomatrix(err_probs.values())).T

def sort_by_list(d: dict, l: list) -> dict:
    return dict(sorted(d.items(), key=lambda pair: l.index(pair[0])))

def subset_occurence(groups, subsets, group_prob_range):
    Aws = [math.binom(subset, lens(groups), group_prob_range) for subset in subsets]
    return np.product(Aws, axis=-1)

def all_subsets(groups):
    return list(it.product( *[tuple(range(N+1)) for N in lens(groups)]))

def protocol_all_subsets(protocol_groups):
    return {cid: all_subsets(groups_dict.values()) for cid,groups_dict in protocol_groups.items()}

def protocol_subset_occurence(protocol_groups, protocol_subsets, group_probs):
    return {cid: {subset: Aw for subset, Aw in zip(subsets, subset_occurence(protocol_groups[cid].values(),subsets,group_probs))}
                  for cid,subsets in protocol_subsets.items()}

# %% ../../06b_sampler.base.ipynb 6
class Sampler:
    
    def __init__(self, protocol, simulator, err_probs={"0":{}}, err_model=None):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = protocol.n_qubits
        self.err_model = err_model() if err_model else E0()
        
        self.protocol_groups = {cid: self.err_model.group(circuit) for cid, circuit in self.protocol._circuits.items()}
        self.protocol_subsets = protocol_all_subsets(self.protocol_groups)
        
        assert isinstance(err_probs, dict)
        assert set(err_probs.keys()) == set(self.err_model.groups)

        self.trees = dict()
        for prob_vec in err_probs_tomatrix(err_probs, self.err_model.groups):
            tree = CountTree(min_path_weight=2 if self.protocol.fault_tolerant else 1)
            tree.constants = protocol_subset_occurence(self.protocol_groups, self.protocol_subsets, prob_vec)
            self.trees[tuple(prob_vec)] = tree
         
    def save(self, path):
        with open(path, 'wb') as fp:
            pickle.dump(self, fp)
    
    @staticmethod
    def load(path):
        with open(path, 'rb') as fp:
            res = pickle.load(fp)
        return res
    
    def optimize(self, tree_node, circuit):
        """Must be overwritten by child class."""
        raise NotImplemented
            
    def run(self, n_samples: int, callbacks=[]) -> None:
        
        self.n_samples = n_samples
        if not isinstance(callbacks, CallbackList):
            callbacks = CallbackList(sampler=self, callbacks=callbacks)
        callbacks.on_sampler_begin()
        
        for prob_vec, tree in self.trees.items():
            
            self.tree_idx = prob_vec
            self.stop_sampling = False
            
            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in prob_vec))}', leave=True):
                
                callbacks.on_protocol_begin()
                if self.stop_sampling: break

                state = self.simulator(self.n_qubits)
                tree_node = None

                for name, circuit in self.protocol:
                    callbacks.on_circuit_begin()

                    tree_node = tree.add(name=name, parent=tree_node, nodetype=Variable)
                    tree_node.counts += 1
                    opt_out = dict()

                    if circuit:
                        if not circuit._noisy:# or circuit.id not in self.protocol_groups.keys():
                            msmt = state.run(circuit)
                        else:
                            opt_out = self.optimize(tree_node, circuit, prob_vec)
                            tree_node = tree.add(name=opt_out['subset'], parent=tree_node, nodetype=Constant, cid=circuit.id,
                                                 is_deterministic=True if circuit._ff_det and not any(opt_out['subset']) else False)
                            tree_node.counts += 1
                            fault_circuit = self.err_model.run(circuit, opt_out['flocs'])

                            msmt = state.run(circuit, fault_circuit)
                        self.protocol.send(msmt)

                    elif name != None:
                        tree_node.marked = True
                    
                    callbacks.on_circuit_end(locals() | opt_out)

                callbacks.on_protocol_end()
            
        callbacks.on_sampler_end()
