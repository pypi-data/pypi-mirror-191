from __future__ import annotations
import sys, re, logging, datetime
from pathlib import Path
from io import IOBase

if sys.version_info[0:2] < (3, 8):
    from typing_extensions import Literal
else:
    from typing import Literal

from . import filemgr
from .filemgr import configure_smb_credentials

from .base import Format
from .csv import CsvFormat
from .tabulate import TabulateFormat
from .excel import ExcelFormat

try:
    # Version generated by setuptools_scm during build
    from ._version import __version__, __version_tuple__
except ImportError:
    __version__ = None
    __version_tuple__ = None


_logger = logging.getLogger(__name__)

_DICT_KEYS_TYPE = type({}.keys())


class Flexout:
    """
    Write text or tabular data to a flexible, easily configurable output: CSV or Excel file, or tabulated stdout/stderr.

    Parameters:

    - `out`:
        - `sys.stdout` (or `"stdout"` or `None`) (default): standard output
        - `sys.stderr` (or `"stderr"`): standard error output
        - a `str` or a `Path`: path to a file that will be opened and closed by Flexout
        - an `IOBase` (already opened)
        - `False` for a noop (does nothing)

    - `format`: `"csv"` (or `CsvFormat`), `"tabulate"` (or `TabulateFormat`, requires package `tabulate`) or `"excel"` (or `ExcelFormat`, requires packages `openpyxl` and `defusedxml`).
        
    Example 1: export text to stdout or to a file:

    ```
    with Flexout(filename or "stdout") as o:
        o.file.write("Content")
    ```
    
    Example 2: export tabular data to stdout or to a file:

    ```
    with Flexout(filename or "stdout") as o:
        o.append_headers("Id", "Word")
        o.append_row(1, "Hello")
        o.append_row(2, "World")
    ```
    """
    
    def __init__(self, out: Path|str|IOBase = None, format: Literal['csv']|Literal['tabulate']|Literal['excel']|type[Format] = None,
                append: bool = False, newline: str = None, encoding: str = None, dialect: str = None, timezone: Literal['local']|Literal['utc']|datetime.timezone = None,
                **pathvars):
        
        self.target: str
        self.target_is_path: bool
        self._file: IOBase
        self._opened_by_me = False

        # Open options
        self._append: bool = append
        self._newline : str = newline
        self._encoding : str = encoding

        # Other format options
        self._dialect: str = dialect

        if isinstance(timezone, str):
            if timezone == 'utc':
                timezone = datetime.timezone.utc
        self._timezone: timezone = timezone

        # Management of tabular data
        self._headers: list = None
        self._wait_for_more_headers: bool = True
        self._delayed_rows: list[list] = []
        self._rows_count: int = 0
        self._missing_in_headers: list[str] = []

        # Determine file (for any data) and table format (for tabular data)
        if out == False or out == "noop":
            self._file = None
            self.target = None
            self.target_is_path = False
            self.format = None
            return # noop

        if isinstance(format, str):
            if format == 'csv':
                format = CsvFormat
            elif format == 'tabulate':
                format = TabulateFormat
            elif format == 'excel':
                format = ExcelFormat
        
        if not out or out == "stdout" or out == sys.stdout:
            self._file = sys.stdout
            self.target = "<stdout>"
            self.target_is_path = False
            if format is None:
                format = TabulateFormat if TabulateFormat.is_available() else CsvFormat

        elif out == "stderr" or out == sys.stderr:
            self._file = sys.stderr
            self.target = "<stderr>"
            self.target_is_path = False
            if format is None:
                format = TabulateFormat if TabulateFormat.is_available() else CsvFormat

        elif isinstance(out, IOBase):
            self._file = out

            try:
                self.target = f"<{getattr(out, 'name')}"
            except AttributeError:
                self.target = f"<{type(out).__name__}"
            self.target_is_path = False

            if format is None:
                format = CsvFormat

        elif isinstance(out, (Path,str)):
            if not isinstance(out, str):
                self.target = str(out)
            else:
                self.target = out
            self.target_is_path = True

            if format is None:
                if re.search(r'\.xlsx(?:#[^\.]+)?$', self.target, re.IGNORECASE):
                    format = ExcelFormat
                else:
                    format = CsvFormat

            # Apply path variables
            if pathvars:
                self.target = self.target.format(**pathvars)

        else:
            raise ValueError(f"invalid type for argument \"out\": {type(out).__name__}")

        # Instanciate format
        if isinstance(format, type) and issubclass(format, Format):
            self.format = format(flexout=self, append=append, newline=newline, encoding=encoding, dialect=dialect, timezone=timezone)
        else:
            raise ValueError(f"invalid type for argument \"tablefmt\": {type(format).__name__}")


    # -------------------------------------------------------------------------
    # Helpers
    # -------------------------------------------------------------------------

    def __str__(self) -> str:
        return self.target if self.target else '<noop>'


    def print_title(self, title: str = None, out = None, level = None):
        if not self.target:
            return # noop
        
        if out or (hasattr(self, '_file') and self._file in [sys.stdout, sys.stderr]):
            if not out:
                out = self._file
            print('\n##########%s##########\n' % (f' {title[0].upper()+title[1:]} ' if title else ''), file=out)
        else:
            _logger.log(level if level is not None else logging.INFO, 'export %sto %s' % (f'{title} ' if title else '', self.target if self.target else '<noop>'))

    
    def get_target_path(self) -> str|None:
        if not self.target_is_path:
            return None
        path, _ = self.split_path_target()
        return path
        

    def split_path_target(self) -> tuple[str,str]|None:
        """
        Return (path, arg).
        """
        if not self.target_is_path:
            return None
        
        pos = self.target.find('#')
        if pos > 0:
            path = self.target[0:pos]
            arg = self.target[pos+1:].replace('-', '_')
        else:
            path = self.target
            arg = None
        
        return (path, arg)


    # -------------------------------------------------------------------------
    # Open/close: used for any data (tabular or not) when the out file is given as a path
    # -------------------------------------------------------------------------

    def __enter__(self):
        return self


    @property
    def file(self) -> IOBase|None:
        """ Get file-like object (open it if necessary), or `None` for noop.  """
        try:
            return getattr(self, '_file')
        except AttributeError:
            self._file = self.format.open_file()
            if self._file:
                self._opened_by_me = True
            return self._file
    

    def __exit__(self, exc_type, exc_val, exc_tb):        
        if exc_type:
            return # forward exception

        if not self.target:
            return # noop
        
        self._flush_delayed()
        
        self.format.before_end()
        if self._opened_by_me and hasattr(self, '_file'):
            self._file.close()
        self.format.after_end()


    # -------------------------------------------------------------------------
    # For tabular data
    # -------------------------------------------------------------------------

    def append_headers(self, *args):
        if not self.target:
            return # noop

        if self._headers is not None:
            raise ValueError("cannot add headers anymore")

        if len(args) == 1 and isinstance(args[0], list):
            self._headers = args[0]
        elif len(args) == 1 and isinstance(args[0], _DICT_KEYS_TYPE):
            self._headers = list(args[0])
        else:
            self._headers = list(args)

        self._wait_for_more_headers = False
        self.format.append_headers(self._headers)


    def append_row(self, *args, nowait=False):
        """
        Add a tabular row.

        If a single dict is passed as argument, keys of the dict are considered to be table headers :
        - If output has already started, the row will be written immediatly (an exception will be raised if any key of the dict does not match the headers)
        - If output has NOT started yet, writing of the row will be delayed (headers will be updated with the keys of the dict), except if option `nowait` is set to True
        """
        if not self.target:
            return # noop
        
        self._rows_count += 1

        if len(args) == 1 and isinstance(args[0], dict):
            # Dict row: keys are headers.

            if self._headers is None:
                self._headers = []
            
            missing_in_headers = []

            row = [None] * len(self._headers)            
            for key, value in args[0].items():
                try:
                    index = self._headers.index(key)
                    row[index] = value
                except:
                    if self._wait_for_more_headers:
                        # add to headers
                        self._headers.append(key)
                        row.append(value)
                    else:
                        # missing in headers: we only warn for the first occurrence                        
                        if not key in self._missing_in_headers:
                            missing_in_headers.append(key)
                            self._missing_in_headers.append(key)

            if missing_in_headers:
                _logger.warning(f"ignore value for key not found in headers: {', '.join(missing_in_headers)} (first occurence on row {self._rows_count})")
            
            if self._wait_for_more_headers and not nowait:
                self._delayed_rows.append(row)
            else:
                self._add_actual_row(row)

        else:
            # Row without header information is given: we write the row immediatly
            if len(args) == 1 and isinstance(args[0], list):
                row = args[0]
            else:
                row = list(args)

            self._add_actual_row(row)

 
    def _add_actual_row(self, row: list):
        """
        Add an actual row, given as a list of value.
        From now on, it is not possible to wait for additional headers anymore.
        """
        self._flush_delayed()
        self.format.append_row(row)


    def _flush_delayed(self):
        if self._wait_for_more_headers:
            self._wait_for_more_headers = False
            if self._headers is not None:
                self.format.append_headers(self._headers)

        if self._delayed_rows:
            for drow in self._delayed_rows:
                self.format.append_row(drow)
            
            self._delayed_rows = []
