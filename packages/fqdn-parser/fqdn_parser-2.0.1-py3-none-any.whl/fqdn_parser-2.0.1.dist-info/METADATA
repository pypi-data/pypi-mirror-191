Metadata-Version: 2.1
Name: fqdn-parser
Version: 2.0.1
Summary: Library to download and use the latest set of TLDs and public multi label domain suffixes from IANA and ICANN
Home-page: https://github.com/jconwell/fqdn_parser/
Author: John Conwell
Author-email: john@iamjohn.me
License: MIT
Project-URL: Documentation, https://github.com/jconwell/fqdn_parser/
Project-URL: Source, https://github.com/jconwell/fqdn_parser/tree/master/fqdn_parser
Project-URL: Changelog, https://github.com/jconwell/fqdn_parser/blob/master/CHANGELOG.rst
Project-URL: Download, https://pypi.org/project/fqdn_parser/#files
Platform: any
Classifier: Development Status :: 4 - Beta
Classifier: Programming Language :: Python
Description-Content-Type: text/x-rst; charset=UTF-8
License-File: LICENSE.txt
Requires-Dist: requests (<3.0,>=2.2)
Requires-Dist: bs4
Requires-Dist: unidecode (>=1.3.6)
Requires-Dist: tranco (>=0.6)
Requires-Dist: pandas
Requires-Dist: importlib-metadata ; python_version < "3.8"
Provides-Extra: testing
Requires-Dist: setuptools ; extra == 'testing'
Requires-Dist: pytest ; extra == 'testing'
Requires-Dist: pytest-cov ; extra == 'testing'

===========
FQDN Parser
===========

--------
Overview
--------

FQDN Parser (Fully Qualified Domain Name Parser) is a library used to (surprise) parse FQDNs into their component parts,
including subdomains, domain names, and the `public suffix <https://publicsuffix.org/list/public_suffix_list.dat>`_.

It also provides additional contextual metadata about the domain's TLD including:

- International TLDs in both unicode and puny code format
- The TLD type: generic, generic-restricted, country-code, sponsored, test, infrastructure, and host_suffix (.onion)
- The date the TLD was registered with ICANN
- In the case of multi-label effective TLDs, is it public like :code:`.co.uk` which is owned by a Registrar or private like :code:`.duckdns.org` which is owned by a private company
- If the TLD (or any label in the FQDN) is puny code encoded, the ascii'ification of the unicode. This can be useful for identifying registrable domains that use unicode characters that are very similar to ascii characters used by legitimate domains, a common phishing technique.

The TLD metadata can be used as contextual features for machine learning models that generate predictions about domain names and FQDNs.

---------------------------------
Data sources used by FQDN Parser:
---------------------------------

- TLD metadata comes from the `IANA Root Zone Database <https://www.iana.org/domains/root/db>`_
- Multi-label suffix data comes from the `Mozilla Public Suffix List <https://publicsuffix.org/list/public_suffix_list.dat>`_

The first time fqdn_parser is run, it will perform two http calls to the links above to pull down the latest ICANN and
Public Suffix List information. This may take a few seconds to pull the data down, parse, and persist into a cache file.
Subsequent calls to fqdn_parser will use the existing cache file and be much faster. The cache file can be managed via
arguments to the :code:`Suffixes` class constructor.

Note: As of the last commit there are 9 country code TLDs listed in the Mozilla Public Suffix List that are `not` listed
in the IANA Root Zone Database for some reason. These TLDs are added to the parsing cache file, but you will see a
warning for each TLD

    :code:`WARNING: 澳门 not in IANA root zone database. Adding to list of TLDs`

-----------
Terminology
-----------

Coming up with a consistent naming convention for each specific part of a FQDN can get a little inconsistent and
confusing.

Take for example :code:`somedomain.co.jp`; many people would call :code:`somedomain` the second level domain, or SLD,
but actually the `2nd` level domain is :code:`.co` and :code:`somedomain` is the `3rd` level domain. But since
most domain names have only 2 levels a lot of people have standardized on SLD. But when writing code logic to parse FQDNs
it is way more clear to be pedantic about naming.

This library uses a very specific naming convention in order to be explicitly clear about what every label means.

    :code:`tld` - the actual top level domain of the FQDN. This is the domain that is controlled by IANA.

    :code:`effective_tld` - this is the full domain suffix, which can be made up of 1 to many labels. The effective
    TLD is the thing a person chooses to register a domain under and is controlled by a Registrar, or in the case of
    private domain suffixes the company that owns the private suffix (like DuckDNS).

    :code:`registrable_domain` - this is the full domain name that a person registers with a Registrar and includes the
    effective tld.

    :code:`registrable_domain_host` - this is the label of the registrable domain without the effective tld. Most people
    call this the second level domain, but as you can see this can get confusing.

    :code:`fqdn` (Fully Qualified Domain Name) - this is the full list of labels.

    :code:`pqdn` (Partially Qualified Domain Name) - this is the  list of sub-domains in a FQDN, not including the
    registrable domain and the effective TLD.

To give a concrete example of these names, take the FQDN :code:`test.integration.api.somedomain.co.jp`

    :code:`tld` - jp

    :code:`effective_tld` - co.jp

    :code:`registrable_domain` - somedomain.co.jp

    :code:`registrable_domain_host` - somedomain

    :code:`fqdn` - test.integration.api.somedomain.co.jp

    :code:`pqdn` - test.integration.api

----------------------------------------------------------------
Doesn't tldextract do this for me? How is fqdn_parser different?
----------------------------------------------------------------

`tldextract <https://github.com/john-kurkowski/tldextract>`_ is a great library if all you need to do
is to parse a FQDN to get it's subdomain, domain, or full suffix.

But fqdn_parser adds a bit more contextual metadata about each TLD/suffix, as well as supports punycoded labels within FQDNs

--------------
Usage Examples
--------------

Parse the registrable domain host from a FQDN:

.. code-block:: python

    from fqdn_parser.suffixes import Suffixes
    suffixes = Suffixes(read_cache=True)
    fqdn = "login.mail.stuffandthings.co.uk"
    result = suffixes.parse(fqdn)
    print(result.registrable_domain_host)

----------------
Private Suffixes
----------------

The "Public Suffix List" (https://publicsuffix.org/list/public_suffix_list.dat) lists all known
public domain suffixes, including both single and multi-label TLDs (.com vs .co.uk).

It also has a section of "Private Suffixes". These are not considered TLDs, but instead are
domain names privately owned by companies that people can get subdomains under. A good example
of this are Dynamic DNS companies. For example, ``duckdns.org`` is a Dynamic DNS provider and you
can register subdomains under ``duckdns.org``.

Private Suffixes can be identified by inspecting the :code:`ParsedResult.private_suffix` property.

Example:

``api.fake_aws_login.duckdns.org``

    :code:`tld` - org

    :code:`effective_tld` - org

    :code:`registrable_domain` - duckdns.org

    :code:`registrable_domain_host` - duckdns

    :code:`private_suffix` - duckdns.org

    :code:`fqdn` - api.fake_aws_login.duckdns.org

    :code:`pqdn` - api.fake_aws_login

A more complex example, using the private suffix ``cdn.prod.atlassian-dev.net``

``assets.some_company.cdn.prod.atlassian-dev.net``

    :code:`tld` - net

    :code:`effective_tld` - net

    :code:`registrable_domain` - atlassian-dev.net

    :code:`registrable_domain_host` - atlassian-dev

    :code:`private_suffix` - cdn.prod.atlassian-dev.net

    :code:`fqdn` - assets.some_company.cdn.prod.atlassian-dev.net

    :code:`pqdn` - assets.some_company

-------
Install
-------

To install via Pypi

:code:`pip install fqdn-parser`

---------------
To Do Wish List
---------------

- A lot of the suffixes listed in https://publicsuffix.org/list/public_suffix_list.dat are not actually
  recognized TLDs, but are suffixes used for Dynamic DNS (https://en.wikipedia.org/wiki/Dynamic_DNS).
  At some point I'd like parse that information and to pull out Dynamic DNS suffixes from actual TLDs.
