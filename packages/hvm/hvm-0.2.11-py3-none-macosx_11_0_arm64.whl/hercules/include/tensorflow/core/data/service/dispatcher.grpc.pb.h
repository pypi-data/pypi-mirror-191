// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensorflow/core/data/service/dispatcher.proto
#ifndef GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED
#define GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED

#include "tensorflow/core/data/service/dispatcher.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace tensorflow {
namespace data {

class DispatcherService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensorflow.data.DispatcherService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Performs a periodic worker heartbeat.
    virtual ::grpc::Status WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::tensorflow::data::WorkerHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>> AsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>>(AsyncWorkerHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>> PrepareAsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>>(PrepareAsyncWorkerHeartbeatRaw(context, request, cq));
    }
    // Updates the dispatcher with information about the worker's state.
    virtual ::grpc::Status WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::tensorflow::data::WorkerUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>> AsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>>(AsyncWorkerUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>> PrepareAsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>>(PrepareAsyncWorkerUpdateRaw(context, request, cq));
    }
    // Gets a dataset defintion.
    virtual ::grpc::Status GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::tensorflow::data::GetDatasetDefResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>> AsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>>(AsyncGetDatasetDefRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>> PrepareAsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>>(PrepareAsyncGetDatasetDefRaw(context, request, cq));
    }
    // Gets the next split for a given job.
    virtual ::grpc::Status GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::tensorflow::data::GetSplitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>> AsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>>(AsyncGetSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>> PrepareAsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>>(PrepareAsyncGetSplitRaw(context, request, cq));
    }
    // Returns the API version of the server.
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::tensorflow::data::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // Registers a dataset with the server, or returns its id if it is already
    // registered.
    //
    // The dataset is constructed in a new graph, so it must not refer to
    // external resources or variables.
    virtual ::grpc::Status GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>> AsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>>(AsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>> PrepareAsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>>(PrepareAsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    // Gets a job if it already exists, otherwise creates it.
    virtual ::grpc::Status GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::tensorflow::data::GetOrCreateJobResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>> AsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>>(AsyncGetOrCreateJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>> PrepareAsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>>(PrepareAsyncGetOrCreateJobRaw(context, request, cq));
    }
    // Attempts to remove a task from a round-robin read job.
    virtual ::grpc::Status MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::tensorflow::data::MaybeRemoveTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>> AsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>>(AsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>> PrepareAsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>>(PrepareAsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    // Releases a job client so that a job may eventually be cleaned up.
    virtual ::grpc::Status ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::tensorflow::data::ReleaseJobClientResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>> AsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>>(AsyncReleaseJobClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>> PrepareAsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>>(PrepareAsyncReleaseJobClientRaw(context, request, cq));
    }
    // Heartbeats from the client. This lets the dispatcher know that the client
    // is still active, and gives the dispatcher a chance to notify the client
    // of new tasks.
    virtual ::grpc::Status ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::tensorflow::data::ClientHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>> AsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>>(AsyncClientHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>> PrepareAsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>>(PrepareAsyncClientHeartbeatRaw(context, request, cq));
    }
    // Reports a list of all workers registered with the dispatcher.
    virtual ::grpc::Status GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::tensorflow::data::GetWorkersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>> AsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>>(AsyncGetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>> PrepareAsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>>(PrepareAsyncGetWorkersRaw(context, request, cq));
    }
    // Returns the element spec for the registered dataset.
    virtual ::grpc::Status GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::tensorflow::data::GetElementSpecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>> AsyncGetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>>(AsyncGetElementSpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>> PrepareAsyncGetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>>(PrepareAsyncGetElementSpecRaw(context, request, cq));
    }
    // Returns the data service metadata for the registered dataset.
    virtual ::grpc::Status GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::tensorflow::data::GetDataServiceMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>> AsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>>(AsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>> PrepareAsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>>(PrepareAsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Performs a periodic worker heartbeat.
      virtual void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Updates the dispatcher with information about the worker's state.
      virtual void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets a dataset defintion.
      virtual void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets the next split for a given job.
      virtual void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns the API version of the server.
      virtual void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Registers a dataset with the server, or returns its id if it is already
      // registered.
      //
      // The dataset is constructed in a new graph, so it must not refer to
      // external resources or variables.
      virtual void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets a job if it already exists, otherwise creates it.
      virtual void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Attempts to remove a task from a round-robin read job.
      virtual void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Releases a job client so that a job may eventually be cleaned up.
      virtual void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Heartbeats from the client. This lets the dispatcher know that the client
      // is still active, and gives the dispatcher a chance to notify the client
      // of new tasks.
      virtual void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Reports a list of all workers registered with the dispatcher.
      virtual void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns the element spec for the registered dataset.
      virtual void GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns the data service metadata for the registered dataset.
      virtual void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>* AsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>* PrepareAsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>* AsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>* PrepareAsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>* AsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>* PrepareAsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>* AsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>* PrepareAsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>* AsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>* PrepareAsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>* AsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>* PrepareAsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>* AsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>* PrepareAsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>* AsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>* PrepareAsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>* AsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>* PrepareAsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>* AsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>* PrepareAsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>* AsyncGetElementSpecRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetElementSpecResponse>* PrepareAsyncGetElementSpecRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>* AsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>* PrepareAsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::tensorflow::data::WorkerHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>> AsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>>(AsyncWorkerHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>> PrepareAsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>>(PrepareAsyncWorkerHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::tensorflow::data::WorkerUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>> AsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>>(AsyncWorkerUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>> PrepareAsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>>(PrepareAsyncWorkerUpdateRaw(context, request, cq));
    }
    ::grpc::Status GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::tensorflow::data::GetDatasetDefResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>> AsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>>(AsyncGetDatasetDefRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>> PrepareAsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>>(PrepareAsyncGetDatasetDefRaw(context, request, cq));
    }
    ::grpc::Status GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::tensorflow::data::GetSplitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>> AsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>>(AsyncGetSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>> PrepareAsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>>(PrepareAsyncGetSplitRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::tensorflow::data::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>> AsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>>(AsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>> PrepareAsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>>(PrepareAsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    ::grpc::Status GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::tensorflow::data::GetOrCreateJobResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>> AsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>>(AsyncGetOrCreateJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>> PrepareAsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>>(PrepareAsyncGetOrCreateJobRaw(context, request, cq));
    }
    ::grpc::Status MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>> AsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>>(AsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>> PrepareAsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>>(PrepareAsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    ::grpc::Status ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::tensorflow::data::ReleaseJobClientResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>> AsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>>(AsyncReleaseJobClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>> PrepareAsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>>(PrepareAsyncReleaseJobClientRaw(context, request, cq));
    }
    ::grpc::Status ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::tensorflow::data::ClientHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>> AsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>>(AsyncClientHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>> PrepareAsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>>(PrepareAsyncClientHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::tensorflow::data::GetWorkersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>> AsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>>(AsyncGetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>> PrepareAsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>>(PrepareAsyncGetWorkersRaw(context, request, cq));
    }
    ::grpc::Status GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::tensorflow::data::GetElementSpecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>> AsyncGetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>>(AsyncGetElementSpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>> PrepareAsyncGetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>>(PrepareAsyncGetElementSpecRaw(context, request, cq));
    }
    ::grpc::Status GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>> AsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>>(AsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>> PrepareAsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>>(PrepareAsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, std::function<void(::grpc::Status)>) override;
      void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response, std::function<void(::grpc::Status)>) override;
      void GetElementSpec(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>* AsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>* PrepareAsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>* AsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>* PrepareAsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>* AsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>* PrepareAsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>* AsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>* PrepareAsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>* AsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>* PrepareAsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>* AsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>* PrepareAsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>* AsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>* PrepareAsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>* AsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>* PrepareAsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>* AsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>* PrepareAsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>* AsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>* PrepareAsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>* AsyncGetElementSpecRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetElementSpecResponse>* PrepareAsyncGetElementSpecRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetElementSpecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>* AsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>* PrepareAsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_WorkerHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_WorkerUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDatasetDef_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSplit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOrRegisterDataset_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOrCreateJob_;
    const ::grpc::internal::RpcMethod rpcmethod_MaybeRemoveTask_;
    const ::grpc::internal::RpcMethod rpcmethod_ReleaseJobClient_;
    const ::grpc::internal::RpcMethod rpcmethod_ClientHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetElementSpec_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDataServiceMetadata_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Performs a periodic worker heartbeat.
    virtual ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response);
    // Updates the dispatcher with information about the worker's state.
    virtual ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response);
    // Gets a dataset defintion.
    virtual ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response);
    // Gets the next split for a given job.
    virtual ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response);
    // Returns the API version of the server.
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response);
    // Registers a dataset with the server, or returns its id if it is already
    // registered.
    //
    // The dataset is constructed in a new graph, so it must not refer to
    // external resources or variables.
    virtual ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response);
    // Gets a job if it already exists, otherwise creates it.
    virtual ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response);
    // Attempts to remove a task from a round-robin read job.
    virtual ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response);
    // Releases a job client so that a job may eventually be cleaned up.
    virtual ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response);
    // Heartbeats from the client. This lets the dispatcher know that the client
    // is still active, and gives the dispatcher a chance to notify the client
    // of new tasks.
    virtual ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response);
    // Reports a list of all workers registered with the dispatcher.
    virtual ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response);
    // Returns the element spec for the registered dataset.
    virtual ::grpc::Status GetElementSpec(::grpc::ServerContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response);
    // Returns the data service metadata for the registered dataset.
    virtual ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerHeartbeat(::grpc::ServerContext* context, ::tensorflow::data::WorkerHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::WorkerHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerUpdate(::grpc::ServerContext* context, ::tensorflow::data::WorkerUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::WorkerUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatasetDef(::grpc::ServerContext* context, ::tensorflow::data::GetDatasetDefRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetDatasetDefResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSplit() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSplit(::grpc::ServerContext* context, ::tensorflow::data::GetSplitRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetSplitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::tensorflow::data::GetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrRegisterDataset(::grpc::ServerContext* context, ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetOrRegisterDatasetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrCreateJob(::grpc::ServerContext* context, ::tensorflow::data::GetOrCreateJobRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetOrCreateJobResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMaybeRemoveTask(::grpc::ServerContext* context, ::tensorflow::data::MaybeRemoveTaskRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::MaybeRemoveTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleaseJobClient(::grpc::ServerContext* context, ::tensorflow::data::ReleaseJobClientRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::ReleaseJobClientResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientHeartbeat(::grpc::ServerContext* context, ::tensorflow::data::ClientHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::ClientHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorkers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkers(::grpc::ServerContext* context, ::tensorflow::data::GetWorkersRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetWorkersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetElementSpec(::grpc::ServerContext* context, ::tensorflow::data::GetElementSpecRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetElementSpecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceMetadata(::grpc::ServerContext* context, ::tensorflow::data::GetDataServiceMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetDataServiceMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_WorkerHeartbeat<WithAsyncMethod_WorkerUpdate<WithAsyncMethod_GetDatasetDef<WithAsyncMethod_GetSplit<WithAsyncMethod_GetVersion<WithAsyncMethod_GetOrRegisterDataset<WithAsyncMethod_GetOrCreateJob<WithAsyncMethod_MaybeRemoveTask<WithAsyncMethod_ReleaseJobClient<WithAsyncMethod_ClientHeartbeat<WithAsyncMethod_GetWorkers<WithAsyncMethod_GetElementSpec<WithAsyncMethod_GetDataServiceMetadata<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response) { return this->WorkerHeartbeat(context, request, response); }));}
    void SetMessageAllocatorFor_WorkerHeartbeat(
        ::grpc::MessageAllocator< ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WorkerHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response) { return this->WorkerUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_WorkerUpdate(
        ::grpc::MessageAllocator< ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WorkerUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response) { return this->GetDatasetDef(context, request, response); }));}
    void SetMessageAllocatorFor_GetDatasetDef(
        ::grpc::MessageAllocator< ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDatasetDef(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSplit() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response) { return this->GetSplit(context, request, response); }));}
    void SetMessageAllocatorFor_GetSplit(
        ::grpc::MessageAllocator< ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSplit(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response) { return this->GetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::MessageAllocator< ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) { return this->GetOrRegisterDataset(context, request, response); }));}
    void SetMessageAllocatorFor_GetOrRegisterDataset(
        ::grpc::MessageAllocator< ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOrRegisterDataset(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response) { return this->GetOrCreateJob(context, request, response); }));}
    void SetMessageAllocatorFor_GetOrCreateJob(
        ::grpc::MessageAllocator< ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOrCreateJob(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response) { return this->MaybeRemoveTask(context, request, response); }));}
    void SetMessageAllocatorFor_MaybeRemoveTask(
        ::grpc::MessageAllocator< ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MaybeRemoveTask(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response) { return this->ReleaseJobClient(context, request, response); }));}
    void SetMessageAllocatorFor_ReleaseJobClient(
        ::grpc::MessageAllocator< ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReleaseJobClient(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response) { return this->ClientHeartbeat(context, request, response); }));}
    void SetMessageAllocatorFor_ClientHeartbeat(
        ::grpc::MessageAllocator< ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetWorkers() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response) { return this->GetWorkers(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorkers(
        ::grpc::MessageAllocator< ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetElementSpecRequest, ::tensorflow::data::GetElementSpecResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetElementSpecRequest* request, ::tensorflow::data::GetElementSpecResponse* response) { return this->GetElementSpec(context, request, response); }));}
    void SetMessageAllocatorFor_GetElementSpec(
        ::grpc::MessageAllocator< ::tensorflow::data::GetElementSpecRequest, ::tensorflow::data::GetElementSpecResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetElementSpecRequest, ::tensorflow::data::GetElementSpecResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetElementSpec(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response) { return this->GetDataServiceMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_GetDataServiceMetadata(
        ::grpc::MessageAllocator< ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDataServiceMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_WorkerHeartbeat<WithCallbackMethod_WorkerUpdate<WithCallbackMethod_GetDatasetDef<WithCallbackMethod_GetSplit<WithCallbackMethod_GetVersion<WithCallbackMethod_GetOrRegisterDataset<WithCallbackMethod_GetOrCreateJob<WithCallbackMethod_MaybeRemoveTask<WithCallbackMethod_ReleaseJobClient<WithCallbackMethod_ClientHeartbeat<WithCallbackMethod_GetWorkers<WithCallbackMethod_GetElementSpec<WithCallbackMethod_GetDataServiceMetadata<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSplit() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorkers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatasetDef(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSplit() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSplit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrRegisterDataset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrCreateJob(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMaybeRemoveTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleaseJobClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorkers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetElementSpec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WorkerHeartbeat(context, request, response); }));
    }
    ~WithRawCallbackMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WorkerHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WorkerUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WorkerUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDatasetDef(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDatasetDef(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSplit() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSplit(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSplit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOrRegisterDataset(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOrRegisterDataset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOrCreateJob(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOrCreateJob(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MaybeRemoveTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MaybeRemoveTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReleaseJobClient(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReleaseJobClient(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClientHeartbeat(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetWorkers() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorkers(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetElementSpec(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetElementSpec(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDataServiceMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDataServiceMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>* streamer) {
                       return this->StreamedWorkerHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerHeartbeatRequest* /*request*/, ::tensorflow::data::WorkerHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWorkerHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::WorkerHeartbeatRequest,::tensorflow::data::WorkerHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>* streamer) {
                       return this->StreamedWorkerUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* /*context*/, const ::tensorflow::data::WorkerUpdateRequest* /*request*/, ::tensorflow::data::WorkerUpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWorkerUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::WorkerUpdateRequest,::tensorflow::data::WorkerUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>* streamer) {
                       return this->StreamedGetDatasetDef(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDatasetDefRequest* /*request*/, ::tensorflow::data::GetDatasetDefResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDatasetDef(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetDatasetDefRequest,::tensorflow::data::GetDatasetDefResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSplit() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>* streamer) {
                       return this->StreamedGetSplit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetSplitRequest* /*request*/, ::tensorflow::data::GetSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSplit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetSplitRequest,::tensorflow::data::GetSplitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>* streamer) {
                       return this->StreamedGetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetVersionRequest* /*request*/, ::tensorflow::data::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetVersionRequest,::tensorflow::data::GetVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>* streamer) {
                       return this->StreamedGetOrRegisterDataset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrRegisterDatasetRequest* /*request*/, ::tensorflow::data::GetOrRegisterDatasetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOrRegisterDataset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetOrRegisterDatasetRequest,::tensorflow::data::GetOrRegisterDatasetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>* streamer) {
                       return this->StreamedGetOrCreateJob(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetOrCreateJobRequest* /*request*/, ::tensorflow::data::GetOrCreateJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOrCreateJob(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetOrCreateJobRequest,::tensorflow::data::GetOrCreateJobResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>* streamer) {
                       return this->StreamedMaybeRemoveTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* /*context*/, const ::tensorflow::data::MaybeRemoveTaskRequest* /*request*/, ::tensorflow::data::MaybeRemoveTaskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMaybeRemoveTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::MaybeRemoveTaskRequest,::tensorflow::data::MaybeRemoveTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>* streamer) {
                       return this->StreamedReleaseJobClient(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ReleaseJobClientRequest* /*request*/, ::tensorflow::data::ReleaseJobClientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReleaseJobClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::ReleaseJobClientRequest,::tensorflow::data::ReleaseJobClientResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>* streamer) {
                       return this->StreamedClientHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* /*context*/, const ::tensorflow::data::ClientHeartbeatRequest* /*request*/, ::tensorflow::data::ClientHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClientHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::ClientHeartbeatRequest,::tensorflow::data::ClientHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorkers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>* streamer) {
                       return this->StreamedGetWorkers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetWorkersRequest* /*request*/, ::tensorflow::data::GetWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetWorkersRequest,::tensorflow::data::GetWorkersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetElementSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetElementSpec() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetElementSpecRequest, ::tensorflow::data::GetElementSpecResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetElementSpecRequest, ::tensorflow::data::GetElementSpecResponse>* streamer) {
                       return this->StreamedGetElementSpec(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetElementSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetElementSpec(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetElementSpecRequest* /*request*/, ::tensorflow::data::GetElementSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetElementSpec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetElementSpecRequest,::tensorflow::data::GetElementSpecResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>* streamer) {
                       return this->StreamedGetDataServiceMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* /*context*/, const ::tensorflow::data::GetDataServiceMetadataRequest* /*request*/, ::tensorflow::data::GetDataServiceMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDataServiceMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetDataServiceMetadataRequest,::tensorflow::data::GetDataServiceMetadataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_WorkerHeartbeat<WithStreamedUnaryMethod_WorkerUpdate<WithStreamedUnaryMethod_GetDatasetDef<WithStreamedUnaryMethod_GetSplit<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetOrRegisterDataset<WithStreamedUnaryMethod_GetOrCreateJob<WithStreamedUnaryMethod_MaybeRemoveTask<WithStreamedUnaryMethod_ReleaseJobClient<WithStreamedUnaryMethod_ClientHeartbeat<WithStreamedUnaryMethod_GetWorkers<WithStreamedUnaryMethod_GetElementSpec<WithStreamedUnaryMethod_GetDataServiceMetadata<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_WorkerHeartbeat<WithStreamedUnaryMethod_WorkerUpdate<WithStreamedUnaryMethod_GetDatasetDef<WithStreamedUnaryMethod_GetSplit<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetOrRegisterDataset<WithStreamedUnaryMethod_GetOrCreateJob<WithStreamedUnaryMethod_MaybeRemoveTask<WithStreamedUnaryMethod_ReleaseJobClient<WithStreamedUnaryMethod_ClientHeartbeat<WithStreamedUnaryMethod_GetWorkers<WithStreamedUnaryMethod_GetElementSpec<WithStreamedUnaryMethod_GetDataServiceMetadata<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace data
}  // namespace tensorflow


#endif  // GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED
