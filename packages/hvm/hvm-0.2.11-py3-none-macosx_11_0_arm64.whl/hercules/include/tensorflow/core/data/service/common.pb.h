// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/data/service/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/protobuf/data_service.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
namespace tensorflow {
namespace data {
class DatasetDef;
struct DatasetDefDefaultTypeInternal;
extern DatasetDefDefaultTypeInternal _DatasetDef_default_instance_;
class TaskDef;
struct TaskDefDefaultTypeInternal;
extern TaskDefDefaultTypeInternal _TaskDef_default_instance_;
class TaskInfo;
struct TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
}  // namespace data
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::data::DatasetDef* Arena::CreateMaybeMessage<::tensorflow::data::DatasetDef>(Arena*);
template<> ::tensorflow::data::TaskDef* Arena::CreateMaybeMessage<::tensorflow::data::TaskDef>(Arena*);
template<> ::tensorflow::data::TaskInfo* Arena::CreateMaybeMessage<::tensorflow::data::TaskInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {
namespace data {

enum TargetWorkers : int {
  TARGET_WORKERS_UNSPECIFIED = 0,
  TARGET_WORKERS_AUTO = 1,
  TARGET_WORKERS_ANY = 2,
  TARGET_WORKERS_LOCAL = 3,
  TargetWorkers_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TargetWorkers_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TargetWorkers_IsValid(int value);
constexpr TargetWorkers TargetWorkers_MIN = TARGET_WORKERS_UNSPECIFIED;
constexpr TargetWorkers TargetWorkers_MAX = TARGET_WORKERS_LOCAL;
constexpr int TargetWorkers_ARRAYSIZE = TargetWorkers_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TargetWorkers_descriptor();
template<typename T>
inline const std::string& TargetWorkers_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TargetWorkers>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TargetWorkers_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TargetWorkers_descriptor(), enum_t_value);
}
inline bool TargetWorkers_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TargetWorkers* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TargetWorkers>(
    TargetWorkers_descriptor(), name, value);
}
// ===================================================================

class DatasetDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.DatasetDef) */ {
 public:
  inline DatasetDef() : DatasetDef(nullptr) {}
  ~DatasetDef() override;
  explicit constexpr DatasetDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetDef(const DatasetDef& from);
  DatasetDef(DatasetDef&& from) noexcept
    : DatasetDef() {
    *this = ::std::move(from);
  }

  inline DatasetDef& operator=(const DatasetDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetDef& operator=(DatasetDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetDef* internal_default_instance() {
    return reinterpret_cast<const DatasetDef*>(
               &_DatasetDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatasetDef& a, DatasetDef& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DatasetDef& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.DatasetDef";
  }
  protected:
  explicit DatasetDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGraphFieldNumber = 1,
  };
  // .tensorflow.GraphDef graph = 1;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::tensorflow::GraphDef& graph() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDef* release_graph();
  ::tensorflow::GraphDef* mutable_graph();
  void set_allocated_graph(::tensorflow::GraphDef* graph);
  private:
  const ::tensorflow::GraphDef& _internal_graph() const;
  ::tensorflow::GraphDef* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::tensorflow::GraphDef* graph);
  ::tensorflow::GraphDef* unsafe_arena_release_graph();

  // @@protoc_insertion_point(class_scope:tensorflow.data.DatasetDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::GraphDef* graph_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TaskDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskDef) */ {
 public:
  inline TaskDef() : TaskDef(nullptr) {}
  ~TaskDef() override;
  explicit constexpr TaskDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskDef(const TaskDef& from);
  TaskDef(TaskDef&& from) noexcept
    : TaskDef() {
    *this = ::std::move(from);
  }

  inline TaskDef& operator=(const TaskDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskDef& operator=(TaskDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskDef& default_instance() {
    return *internal_default_instance();
  }
  enum DatasetCase {
    kDatasetDef = 1,
    kPath = 2,
    DATASET_NOT_SET = 0,
  };

  enum OptionalNumConsumersCase {
    kNumConsumers = 7,
    OPTIONAL_NUM_CONSUMERS_NOT_SET = 0,
  };

  static inline const TaskDef* internal_default_instance() {
    return reinterpret_cast<const TaskDef*>(
               &_TaskDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskDef& a, TaskDef& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskDef& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.TaskDef";
  }
  protected:
  explicit TaskDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerAddressFieldNumber = 8,
    kProcessingModeDefFieldNumber = 10,
    kDatasetIdFieldNumber = 3,
    kTaskIdFieldNumber = 4,
    kJobIdFieldNumber = 5,
    kNumSplitProvidersFieldNumber = 9,
    kNumWorkersFieldNumber = 11,
    kWorkerIndexFieldNumber = 12,
    kDatasetDefFieldNumber = 1,
    kPathFieldNumber = 2,
    kNumConsumersFieldNumber = 7,
  };
  // string worker_address = 8;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_NODISCARD std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
  bool has_processing_mode_def() const;
  private:
  bool _internal_has_processing_mode_def() const;
  public:
  void clear_processing_mode_def();
  const ::tensorflow::data::ProcessingModeDef& processing_mode_def() const;
  PROTOBUF_NODISCARD ::tensorflow::data::ProcessingModeDef* release_processing_mode_def();
  ::tensorflow::data::ProcessingModeDef* mutable_processing_mode_def();
  void set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def);
  private:
  const ::tensorflow::data::ProcessingModeDef& _internal_processing_mode_def() const;
  ::tensorflow::data::ProcessingModeDef* _internal_mutable_processing_mode_def();
  public:
  void unsafe_arena_set_allocated_processing_mode_def(
      ::tensorflow::data::ProcessingModeDef* processing_mode_def);
  ::tensorflow::data::ProcessingModeDef* unsafe_arena_release_processing_mode_def();

  // int64 dataset_id = 3;
  void clear_dataset_id();
  int64_t dataset_id() const;
  void set_dataset_id(int64_t value);
  private:
  int64_t _internal_dataset_id() const;
  void _internal_set_dataset_id(int64_t value);
  public:

  // int64 task_id = 4;
  void clear_task_id();
  int64_t task_id() const;
  void set_task_id(int64_t value);
  private:
  int64_t _internal_task_id() const;
  void _internal_set_task_id(int64_t value);
  public:

  // int64 job_id = 5;
  void clear_job_id();
  int64_t job_id() const;
  void set_job_id(int64_t value);
  private:
  int64_t _internal_job_id() const;
  void _internal_set_job_id(int64_t value);
  public:

  // int64 num_split_providers = 9;
  void clear_num_split_providers();
  int64_t num_split_providers() const;
  void set_num_split_providers(int64_t value);
  private:
  int64_t _internal_num_split_providers() const;
  void _internal_set_num_split_providers(int64_t value);
  public:

  // int64 num_workers = 11;
  void clear_num_workers();
  int64_t num_workers() const;
  void set_num_workers(int64_t value);
  private:
  int64_t _internal_num_workers() const;
  void _internal_set_num_workers(int64_t value);
  public:

  // int64 worker_index = 12;
  void clear_worker_index();
  int64_t worker_index() const;
  void set_worker_index(int64_t value);
  private:
  int64_t _internal_worker_index() const;
  void _internal_set_worker_index(int64_t value);
  public:

  // .tensorflow.data.DatasetDef dataset_def = 1;
  bool has_dataset_def() const;
  private:
  bool _internal_has_dataset_def() const;
  public:
  void clear_dataset_def();
  const ::tensorflow::data::DatasetDef& dataset_def() const;
  PROTOBUF_NODISCARD ::tensorflow::data::DatasetDef* release_dataset_def();
  ::tensorflow::data::DatasetDef* mutable_dataset_def();
  void set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def);
  private:
  const ::tensorflow::data::DatasetDef& _internal_dataset_def() const;
  ::tensorflow::data::DatasetDef* _internal_mutable_dataset_def();
  public:
  void unsafe_arena_set_allocated_dataset_def(
      ::tensorflow::data::DatasetDef* dataset_def);
  ::tensorflow::data::DatasetDef* unsafe_arena_release_dataset_def();

  // string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int64 num_consumers = 7;
  bool has_num_consumers() const;
  private:
  bool _internal_has_num_consumers() const;
  public:
  void clear_num_consumers();
  int64_t num_consumers() const;
  void set_num_consumers(int64_t value);
  private:
  int64_t _internal_num_consumers() const;
  void _internal_set_num_consumers(int64_t value);
  public:

  void clear_dataset();
  DatasetCase dataset_case() const;
  void clear_optional_num_consumers();
  OptionalNumConsumersCase optional_num_consumers_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskDef)
 private:
  class _Internal;
  void set_has_dataset_def();
  void set_has_path();
  void set_has_num_consumers();

  inline bool has_dataset() const;
  inline void clear_has_dataset();

  inline bool has_optional_num_consumers() const;
  inline void clear_has_optional_num_consumers();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
  ::tensorflow::data::ProcessingModeDef* processing_mode_def_;
  int64_t dataset_id_;
  int64_t task_id_;
  int64_t job_id_;
  int64_t num_split_providers_;
  int64_t num_workers_;
  int64_t worker_index_;
  union DatasetUnion {
    constexpr DatasetUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tensorflow::data::DatasetDef* dataset_def_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  } dataset_;
  union OptionalNumConsumersUnion {
    constexpr OptionalNumConsumersUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int64_t num_consumers_;
  } optional_num_consumers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TaskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskInfo) */ {
 public:
  inline TaskInfo() : TaskInfo(nullptr) {}
  ~TaskInfo() override;
  explicit constexpr TaskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInfo(const TaskInfo& from);
  TaskInfo(TaskInfo&& from) noexcept
    : TaskInfo() {
    *this = ::std::move(from);
  }

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInfo& operator=(TaskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInfo* internal_default_instance() {
    return reinterpret_cast<const TaskInfo*>(
               &_TaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskInfo& a, TaskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.TaskInfo";
  }
  protected:
  explicit TaskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerTagsFieldNumber = 6,
    kWorkerAddressFieldNumber = 1,
    kTransferAddressFieldNumber = 4,
    kTaskIdFieldNumber = 2,
    kJobIdFieldNumber = 3,
    kStartingRoundFieldNumber = 5,
    kWorkerUidFieldNumber = 7,
  };
  // repeated string worker_tags = 6;
  int worker_tags_size() const;
  private:
  int _internal_worker_tags_size() const;
  public:
  void clear_worker_tags();
  const std::string& worker_tags(int index) const;
  std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const std::string& value);
  void set_worker_tags(int index, std::string&& value);
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  std::string* add_worker_tags();
  void add_worker_tags(const std::string& value);
  void add_worker_tags(std::string&& value);
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& worker_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_worker_tags();
  private:
  const std::string& _internal_worker_tags(int index) const;
  std::string* _internal_add_worker_tags();
  public:

  // string worker_address = 1;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_NODISCARD std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // string transfer_address = 4;
  void clear_transfer_address();
  const std::string& transfer_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transfer_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transfer_address();
  PROTOBUF_NODISCARD std::string* release_transfer_address();
  void set_allocated_transfer_address(std::string* transfer_address);
  private:
  const std::string& _internal_transfer_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transfer_address(const std::string& value);
  std::string* _internal_mutable_transfer_address();
  public:

  // int64 task_id = 2;
  void clear_task_id();
  int64_t task_id() const;
  void set_task_id(int64_t value);
  private:
  int64_t _internal_task_id() const;
  void _internal_set_task_id(int64_t value);
  public:

  // int64 job_id = 3;
  void clear_job_id();
  int64_t job_id() const;
  void set_job_id(int64_t value);
  private:
  int64_t _internal_job_id() const;
  void _internal_set_job_id(int64_t value);
  public:

  // int64 starting_round = 5;
  void clear_starting_round();
  int64_t starting_round() const;
  void set_starting_round(int64_t value);
  private:
  int64_t _internal_starting_round() const;
  void _internal_set_starting_round(int64_t value);
  public:

  // int64 worker_uid = 7;
  void clear_worker_uid();
  int64_t worker_uid() const;
  void set_worker_uid(int64_t value);
  private:
  int64_t _internal_worker_uid() const;
  void _internal_set_worker_uid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> worker_tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transfer_address_;
  int64_t task_id_;
  int64_t job_id_;
  int64_t starting_round_;
  int64_t worker_uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatasetDef

// .tensorflow.GraphDef graph = 1;
inline bool DatasetDef::_internal_has_graph() const {
  return this != internal_default_instance() && graph_ != nullptr;
}
inline bool DatasetDef::has_graph() const {
  return _internal_has_graph();
}
inline const ::tensorflow::GraphDef& DatasetDef::_internal_graph() const {
  const ::tensorflow::GraphDef* p = graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDef&>(
      ::tensorflow::_GraphDef_default_instance_);
}
inline const ::tensorflow::GraphDef& DatasetDef::graph() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DatasetDef.graph)
  return _internal_graph();
}
inline void DatasetDef::unsafe_arena_set_allocated_graph(
    ::tensorflow::GraphDef* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.DatasetDef.graph)
}
inline ::tensorflow::GraphDef* DatasetDef::release_graph() {
  
  ::tensorflow::GraphDef* temp = graph_;
  graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::GraphDef* DatasetDef::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DatasetDef.graph)
  
  ::tensorflow::GraphDef* temp = graph_;
  graph_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDef* DatasetDef::_internal_mutable_graph() {
  
  if (graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::GraphDef>(GetArenaForAllocation());
    graph_ = p;
  }
  return graph_;
}
inline ::tensorflow::GraphDef* DatasetDef::mutable_graph() {
  ::tensorflow::GraphDef* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DatasetDef.graph)
  return _msg;
}
inline void DatasetDef::set_allocated_graph(::tensorflow::GraphDef* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph));
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DatasetDef.graph)
}

// -------------------------------------------------------------------

// TaskDef

// .tensorflow.data.DatasetDef dataset_def = 1;
inline bool TaskDef::_internal_has_dataset_def() const {
  return dataset_case() == kDatasetDef;
}
inline bool TaskDef::has_dataset_def() const {
  return _internal_has_dataset_def();
}
inline void TaskDef::set_has_dataset_def() {
  _oneof_case_[0] = kDatasetDef;
}
inline void TaskDef::clear_dataset_def() {
  if (_internal_has_dataset_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dataset_.dataset_def_;
    }
    clear_has_dataset();
  }
}
inline ::tensorflow::data::DatasetDef* TaskDef::release_dataset_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.dataset_def)
  if (_internal_has_dataset_def()) {
    clear_has_dataset();
      ::tensorflow::data::DatasetDef* temp = dataset_.dataset_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dataset_.dataset_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::data::DatasetDef& TaskDef::_internal_dataset_def() const {
  return _internal_has_dataset_def()
      ? *dataset_.dataset_def_
      : reinterpret_cast< ::tensorflow::data::DatasetDef&>(::tensorflow::data::_DatasetDef_default_instance_);
}
inline const ::tensorflow::data::DatasetDef& TaskDef::dataset_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_def)
  return _internal_dataset_def();
}
inline ::tensorflow::data::DatasetDef* TaskDef::unsafe_arena_release_dataset_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.data.TaskDef.dataset_def)
  if (_internal_has_dataset_def()) {
    clear_has_dataset();
    ::tensorflow::data::DatasetDef* temp = dataset_.dataset_def_;
    dataset_.dataset_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskDef::unsafe_arena_set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def) {
  clear_dataset();
  if (dataset_def) {
    set_has_dataset_def();
    dataset_.dataset_def_ = dataset_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.TaskDef.dataset_def)
}
inline ::tensorflow::data::DatasetDef* TaskDef::_internal_mutable_dataset_def() {
  if (!_internal_has_dataset_def()) {
    clear_dataset();
    set_has_dataset_def();
    dataset_.dataset_def_ = CreateMaybeMessage< ::tensorflow::data::DatasetDef >(GetArenaForAllocation());
  }
  return dataset_.dataset_def_;
}
inline ::tensorflow::data::DatasetDef* TaskDef::mutable_dataset_def() {
  ::tensorflow::data::DatasetDef* _msg = _internal_mutable_dataset_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.dataset_def)
  return _msg;
}

// string path = 2;
inline bool TaskDef::_internal_has_path() const {
  return dataset_case() == kPath;
}
inline bool TaskDef::has_path() const {
  return _internal_has_path();
}
inline void TaskDef::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void TaskDef::clear_path() {
  if (_internal_has_path()) {
    dataset_.path_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_dataset();
  }
}
inline const std::string& TaskDef::path() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline void TaskDef::set_path(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.path)
}
inline std::string* TaskDef::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.path)
  return _s;
}
inline const std::string& TaskDef::_internal_path() const {
  if (_internal_has_path()) {
    return dataset_.path_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TaskDef::_internal_set_path(const std::string& value) {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskDef::_internal_mutable_path() {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return dataset_.path_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskDef::release_path() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.path)
  if (_internal_has_path()) {
    clear_has_dataset();
    return dataset_.path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TaskDef::set_allocated_path(std::string* path) {
  if (has_dataset()) {
    clear_dataset();
  }
  if (path != nullptr) {
    set_has_path();
    dataset_.path_.UnsafeSetDefault(path);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(path);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.path)
}

// int64 dataset_id = 3;
inline void TaskDef::clear_dataset_id() {
  dataset_id_ = int64_t{0};
}
inline int64_t TaskDef::_internal_dataset_id() const {
  return dataset_id_;
}
inline int64_t TaskDef::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_id)
  return _internal_dataset_id();
}
inline void TaskDef::_internal_set_dataset_id(int64_t value) {
  
  dataset_id_ = value;
}
inline void TaskDef::set_dataset_id(int64_t value) {
  _internal_set_dataset_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.dataset_id)
}

// int64 task_id = 4;
inline void TaskDef::clear_task_id() {
  task_id_ = int64_t{0};
}
inline int64_t TaskDef::_internal_task_id() const {
  return task_id_;
}
inline int64_t TaskDef::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.task_id)
  return _internal_task_id();
}
inline void TaskDef::_internal_set_task_id(int64_t value) {
  
  task_id_ = value;
}
inline void TaskDef::set_task_id(int64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.task_id)
}

// int64 job_id = 5;
inline void TaskDef::clear_job_id() {
  job_id_ = int64_t{0};
}
inline int64_t TaskDef::_internal_job_id() const {
  return job_id_;
}
inline int64_t TaskDef::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.job_id)
  return _internal_job_id();
}
inline void TaskDef::_internal_set_job_id(int64_t value) {
  
  job_id_ = value;
}
inline void TaskDef::set_job_id(int64_t value) {
  _internal_set_job_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.job_id)
}

// int64 num_split_providers = 9;
inline void TaskDef::clear_num_split_providers() {
  num_split_providers_ = int64_t{0};
}
inline int64_t TaskDef::_internal_num_split_providers() const {
  return num_split_providers_;
}
inline int64_t TaskDef::num_split_providers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_split_providers)
  return _internal_num_split_providers();
}
inline void TaskDef::_internal_set_num_split_providers(int64_t value) {
  
  num_split_providers_ = value;
}
inline void TaskDef::set_num_split_providers(int64_t value) {
  _internal_set_num_split_providers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_split_providers)
}

// string worker_address = 8;
inline void TaskDef::clear_worker_address() {
  worker_address_.ClearToEmpty();
}
inline const std::string& TaskDef::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskDef::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_address)
}
inline std::string* TaskDef::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.worker_address)
  return _s;
}
inline const std::string& TaskDef::_internal_worker_address() const {
  return worker_address_.Get();
}
inline void TaskDef::_internal_set_worker_address(const std::string& value) {
  
  worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskDef::_internal_mutable_worker_address() {
  
  return worker_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskDef::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.worker_address)
  return worker_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskDef::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  worker_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (worker_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    worker_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.worker_address)
}

// .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
inline bool TaskDef::_internal_has_processing_mode_def() const {
  return this != internal_default_instance() && processing_mode_def_ != nullptr;
}
inline bool TaskDef::has_processing_mode_def() const {
  return _internal_has_processing_mode_def();
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::_internal_processing_mode_def() const {
  const ::tensorflow::data::ProcessingModeDef* p = processing_mode_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::ProcessingModeDef&>(
      ::tensorflow::data::_ProcessingModeDef_default_instance_);
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::processing_mode_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.processing_mode_def)
  return _internal_processing_mode_def();
}
inline void TaskDef::unsafe_arena_set_allocated_processing_mode_def(
    ::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(processing_mode_def_);
  }
  processing_mode_def_ = processing_mode_def;
  if (processing_mode_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.TaskDef.processing_mode_def)
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::release_processing_mode_def() {
  
  ::tensorflow::data::ProcessingModeDef* temp = processing_mode_def_;
  processing_mode_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::unsafe_arena_release_processing_mode_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.processing_mode_def)
  
  ::tensorflow::data::ProcessingModeDef* temp = processing_mode_def_;
  processing_mode_def_ = nullptr;
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::_internal_mutable_processing_mode_def() {
  
  if (processing_mode_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::data::ProcessingModeDef>(GetArenaForAllocation());
    processing_mode_def_ = p;
  }
  return processing_mode_def_;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::mutable_processing_mode_def() {
  ::tensorflow::data::ProcessingModeDef* _msg = _internal_mutable_processing_mode_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.processing_mode_def)
  return _msg;
}
inline void TaskDef::set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(processing_mode_def_);
  }
  if (processing_mode_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(processing_mode_def));
    if (message_arena != submessage_arena) {
      processing_mode_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processing_mode_def, submessage_arena);
    }
    
  } else {
    
  }
  processing_mode_def_ = processing_mode_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.processing_mode_def)
}

// int64 num_consumers = 7;
inline bool TaskDef::_internal_has_num_consumers() const {
  return optional_num_consumers_case() == kNumConsumers;
}
inline bool TaskDef::has_num_consumers() const {
  return _internal_has_num_consumers();
}
inline void TaskDef::set_has_num_consumers() {
  _oneof_case_[1] = kNumConsumers;
}
inline void TaskDef::clear_num_consumers() {
  if (_internal_has_num_consumers()) {
    optional_num_consumers_.num_consumers_ = int64_t{0};
    clear_has_optional_num_consumers();
  }
}
inline int64_t TaskDef::_internal_num_consumers() const {
  if (_internal_has_num_consumers()) {
    return optional_num_consumers_.num_consumers_;
  }
  return int64_t{0};
}
inline void TaskDef::_internal_set_num_consumers(int64_t value) {
  if (!_internal_has_num_consumers()) {
    clear_optional_num_consumers();
    set_has_num_consumers();
  }
  optional_num_consumers_.num_consumers_ = value;
}
inline int64_t TaskDef::num_consumers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_consumers)
  return _internal_num_consumers();
}
inline void TaskDef::set_num_consumers(int64_t value) {
  _internal_set_num_consumers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_consumers)
}

// int64 num_workers = 11;
inline void TaskDef::clear_num_workers() {
  num_workers_ = int64_t{0};
}
inline int64_t TaskDef::_internal_num_workers() const {
  return num_workers_;
}
inline int64_t TaskDef::num_workers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_workers)
  return _internal_num_workers();
}
inline void TaskDef::_internal_set_num_workers(int64_t value) {
  
  num_workers_ = value;
}
inline void TaskDef::set_num_workers(int64_t value) {
  _internal_set_num_workers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_workers)
}

// int64 worker_index = 12;
inline void TaskDef::clear_worker_index() {
  worker_index_ = int64_t{0};
}
inline int64_t TaskDef::_internal_worker_index() const {
  return worker_index_;
}
inline int64_t TaskDef::worker_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_index)
  return _internal_worker_index();
}
inline void TaskDef::_internal_set_worker_index(int64_t value) {
  
  worker_index_ = value;
}
inline void TaskDef::set_worker_index(int64_t value) {
  _internal_set_worker_index(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_index)
}

inline bool TaskDef::has_dataset() const {
  return dataset_case() != DATASET_NOT_SET;
}
inline void TaskDef::clear_has_dataset() {
  _oneof_case_[0] = DATASET_NOT_SET;
}
inline bool TaskDef::has_optional_num_consumers() const {
  return optional_num_consumers_case() != OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline void TaskDef::clear_has_optional_num_consumers() {
  _oneof_case_[1] = OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline TaskDef::DatasetCase TaskDef::dataset_case() const {
  return TaskDef::DatasetCase(_oneof_case_[0]);
}
inline TaskDef::OptionalNumConsumersCase TaskDef::optional_num_consumers_case() const {
  return TaskDef::OptionalNumConsumersCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TaskInfo

// string worker_address = 1;
inline void TaskInfo::clear_worker_address() {
  worker_address_.ClearToEmpty();
}
inline const std::string& TaskInfo::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfo::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_address)
}
inline std::string* TaskInfo::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_address)
  return _s;
}
inline const std::string& TaskInfo::_internal_worker_address() const {
  return worker_address_.Get();
}
inline void TaskInfo::_internal_set_worker_address(const std::string& value) {
  
  worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_worker_address() {
  
  return worker_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfo::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskInfo.worker_address)
  return worker_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfo::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  worker_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (worker_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    worker_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskInfo.worker_address)
}

// string transfer_address = 4;
inline void TaskInfo::clear_transfer_address() {
  transfer_address_.ClearToEmpty();
}
inline const std::string& TaskInfo::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.transfer_address)
  return _internal_transfer_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfo::set_transfer_address(ArgT0&& arg0, ArgT... args) {
 
 transfer_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.transfer_address)
}
inline std::string* TaskInfo::mutable_transfer_address() {
  std::string* _s = _internal_mutable_transfer_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.transfer_address)
  return _s;
}
inline const std::string& TaskInfo::_internal_transfer_address() const {
  return transfer_address_.Get();
}
inline void TaskInfo::_internal_set_transfer_address(const std::string& value) {
  
  transfer_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_transfer_address() {
  
  return transfer_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfo::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskInfo.transfer_address)
  return transfer_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfo::set_allocated_transfer_address(std::string* transfer_address) {
  if (transfer_address != nullptr) {
    
  } else {
    
  }
  transfer_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transfer_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transfer_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transfer_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskInfo.transfer_address)
}

// repeated string worker_tags = 6;
inline int TaskInfo::_internal_worker_tags_size() const {
  return worker_tags_.size();
}
inline int TaskInfo::worker_tags_size() const {
  return _internal_worker_tags_size();
}
inline void TaskInfo::clear_worker_tags() {
  worker_tags_.Clear();
}
inline std::string* TaskInfo::add_worker_tags() {
  std::string* _s = _internal_add_worker_tags();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.TaskInfo.worker_tags)
  return _s;
}
inline const std::string& TaskInfo::_internal_worker_tags(int index) const {
  return worker_tags_.Get(index);
}
inline const std::string& TaskInfo::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_tags)
  return _internal_worker_tags(index);
}
inline std::string* TaskInfo::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void TaskInfo::set_worker_tags(int index, const std::string& value) {
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, std::string&& value) {
  worker_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline std::string* TaskInfo::_internal_add_worker_tags() {
  return worker_tags_.Add();
}
inline void TaskInfo::add_worker_tags(const std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskInfo::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskInfo::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.TaskInfo.worker_tags)
  return &worker_tags_;
}

// int64 task_id = 2;
inline void TaskInfo::clear_task_id() {
  task_id_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_task_id() const {
  return task_id_;
}
inline int64_t TaskInfo::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.task_id)
  return _internal_task_id();
}
inline void TaskInfo::_internal_set_task_id(int64_t value) {
  
  task_id_ = value;
}
inline void TaskInfo::set_task_id(int64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.task_id)
}

// int64 job_id = 3;
inline void TaskInfo::clear_job_id() {
  job_id_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_job_id() const {
  return job_id_;
}
inline int64_t TaskInfo::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.job_id)
  return _internal_job_id();
}
inline void TaskInfo::_internal_set_job_id(int64_t value) {
  
  job_id_ = value;
}
inline void TaskInfo::set_job_id(int64_t value) {
  _internal_set_job_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.job_id)
}

// int64 worker_uid = 7;
inline void TaskInfo::clear_worker_uid() {
  worker_uid_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_worker_uid() const {
  return worker_uid_;
}
inline int64_t TaskInfo::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_uid)
  return _internal_worker_uid();
}
inline void TaskInfo::_internal_set_worker_uid(int64_t value) {
  
  worker_uid_ = value;
}
inline void TaskInfo::set_worker_uid(int64_t value) {
  _internal_set_worker_uid(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_uid)
}

// int64 starting_round = 5;
inline void TaskInfo::clear_starting_round() {
  starting_round_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_starting_round() const {
  return starting_round_;
}
inline int64_t TaskInfo::starting_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.starting_round)
  return _internal_starting_round();
}
inline void TaskInfo::_internal_set_starting_round(int64_t value) {
  
  starting_round_ = value;
}
inline void TaskInfo::set_starting_round(int64_t value) {
  _internal_set_starting_round(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.starting_round)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace tensorflow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tensorflow::data::TargetWorkers> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::data::TargetWorkers>() {
  return ::tensorflow::data::TargetWorkers_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
