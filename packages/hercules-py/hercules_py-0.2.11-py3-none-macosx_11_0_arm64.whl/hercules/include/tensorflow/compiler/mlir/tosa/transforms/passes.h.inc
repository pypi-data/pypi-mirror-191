/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// TosaConvertTFLUint8Pass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaConvertTFLUint8PassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaConvertTFLUint8PassBase;

  TosaConvertTFLUint8PassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaConvertTFLUint8PassBase(const TosaConvertTFLUint8PassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-convert-tfl-uint8");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-convert-tfl-uint8"; }

  ::llvm::StringRef getDescription() const override { return "Convert uint8 graph to int8 graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaConvertTFLUint8Pass");
  }
  ::llvm::StringRef getName() const override { return "TosaConvertTFLUint8Pass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// TosaFusebiasTFPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaFusebiasTFPassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaFusebiasTFPassBase;

  TosaFusebiasTFPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaFusebiasTFPassBase(const TosaFusebiasTFPassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-fuse-bias-tf");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-fuse-bias-tf"; }

  ::llvm::StringRef getDescription() const override { return "Fuse tf.Op + tf.BiasAdd and legalized to TOSA"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaFusebiasTFPass");
  }
  ::llvm::StringRef getName() const override { return "TosaFusebiasTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// TosaLegalizeTFLPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaLegalizeTFLPassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaLegalizeTFLPassBase;

  TosaLegalizeTFLPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaLegalizeTFLPassBase(const TosaLegalizeTFLPassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-legalize-tfl");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-legalize-tfl"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TensorFlow Lite to TOSA"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLegalizeTFLPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLegalizeTFLPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// TosaLegalizeTFPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaLegalizeTFPassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaLegalizeTFPassBase;

  TosaLegalizeTFPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaLegalizeTFPassBase(const TosaLegalizeTFPassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-legalize-tf");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-legalize-tf"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TensorFlow to TOSA"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLegalizeTFPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLegalizeTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  registry.insert<quant::QuantizationDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// TosaLegalizeTFTFLPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaLegalizeTFTFLPassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaLegalizeTFTFLPassBase;

  TosaLegalizeTFTFLPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaLegalizeTFTFLPassBase(const TosaLegalizeTFTFLPassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-legalize-tf-tfl");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-legalize-tf-tfl"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TensorFlow / TensorFlow Lite to TOSA"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLegalizeTFTFLPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLegalizeTFTFLPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// TosaStripQuantTypesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TosaStripQuantTypesPassBase : public ::mlir::FunctionPass {
public:
  using Base = TosaStripQuantTypesPassBase;

  TosaStripQuantTypesPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  TosaStripQuantTypesPassBase(const TosaStripQuantTypesPassBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-strip-quant-types");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-strip-quant-types"; }

  ::llvm::StringRef getDescription() const override { return "Convert all quant types to their storage type."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaStripQuantTypesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaStripQuantTypesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TosaDialect>();

  }

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TosaConvertTFLUint8Pass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaConvertTFLUint8PassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertTFLUint8Pass();
  });
}

//===----------------------------------------------------------------------===//
// TosaFusebiasTFPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaFusebiasTFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFuseBiasTFPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaLegalizeTFLPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaLegalizeTFLPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTFLPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaLegalizeTFPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaLegalizeTFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTFPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaLegalizeTFTFLPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaLegalizeTFTFLPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTFTFLPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaStripQuantTypesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaStripQuantTypesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStripQuantTypesPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTosa Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTosaPasses() {
  registerTosaConvertTFLUint8PassPass();
  registerTosaFusebiasTFPassPass();
  registerTosaLegalizeTFLPassPass();
  registerTosaLegalizeTFPassPass();
  registerTosaLegalizeTFTFLPassPass();
  registerTosaStripQuantTypesPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
