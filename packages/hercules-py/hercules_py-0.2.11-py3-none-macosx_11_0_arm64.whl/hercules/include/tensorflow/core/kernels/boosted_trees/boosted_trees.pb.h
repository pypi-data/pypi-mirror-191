// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/kernels/boosted_trees/boosted_trees.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
namespace tensorflow {
namespace boosted_trees {
class BucketizedSplit;
struct BucketizedSplitDefaultTypeInternal;
extern BucketizedSplitDefaultTypeInternal _BucketizedSplit_default_instance_;
class CategoricalSplit;
struct CategoricalSplitDefaultTypeInternal;
extern CategoricalSplitDefaultTypeInternal _CategoricalSplit_default_instance_;
class DebugOutput;
struct DebugOutputDefaultTypeInternal;
extern DebugOutputDefaultTypeInternal _DebugOutput_default_instance_;
class DenseSplit;
struct DenseSplitDefaultTypeInternal;
extern DenseSplitDefaultTypeInternal _DenseSplit_default_instance_;
class GrowingMetadata;
struct GrowingMetadataDefaultTypeInternal;
extern GrowingMetadataDefaultTypeInternal _GrowingMetadata_default_instance_;
class Leaf;
struct LeafDefaultTypeInternal;
extern LeafDefaultTypeInternal _Leaf_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeMetadata;
struct NodeMetadataDefaultTypeInternal;
extern NodeMetadataDefaultTypeInternal _NodeMetadata_default_instance_;
class SparseVector;
struct SparseVectorDefaultTypeInternal;
extern SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
class Tree;
struct TreeDefaultTypeInternal;
extern TreeDefaultTypeInternal _Tree_default_instance_;
class TreeEnsemble;
struct TreeEnsembleDefaultTypeInternal;
extern TreeEnsembleDefaultTypeInternal _TreeEnsemble_default_instance_;
class TreeMetadata;
struct TreeMetadataDefaultTypeInternal;
extern TreeMetadataDefaultTypeInternal _TreeMetadata_default_instance_;
class TreeMetadata_PostPruneNodeUpdate;
struct TreeMetadata_PostPruneNodeUpdateDefaultTypeInternal;
extern TreeMetadata_PostPruneNodeUpdateDefaultTypeInternal _TreeMetadata_PostPruneNodeUpdate_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace boosted_trees
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::boosted_trees::BucketizedSplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::BucketizedSplit>(Arena*);
template<> ::tensorflow::boosted_trees::CategoricalSplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::CategoricalSplit>(Arena*);
template<> ::tensorflow::boosted_trees::DebugOutput* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::DebugOutput>(Arena*);
template<> ::tensorflow::boosted_trees::DenseSplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::DenseSplit>(Arena*);
template<> ::tensorflow::boosted_trees::GrowingMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::GrowingMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::Leaf* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::Leaf>(Arena*);
template<> ::tensorflow::boosted_trees::Node* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::Node>(Arena*);
template<> ::tensorflow::boosted_trees::NodeMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::NodeMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::SparseVector* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::SparseVector>(Arena*);
template<> ::tensorflow::boosted_trees::Tree* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::Tree>(Arena*);
template<> ::tensorflow::boosted_trees::TreeEnsemble* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::TreeEnsemble>(Arena*);
template<> ::tensorflow::boosted_trees::TreeMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::TreeMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate>(Arena*);
template<> ::tensorflow::boosted_trees::Vector* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {
namespace boosted_trees {

enum SplitTypeWithDefault : int {
  INEQUALITY_DEFAULT_LEFT = 0,
  INEQUALITY_DEFAULT_RIGHT = 1,
  EQUALITY_DEFAULT_RIGHT = 3,
  SplitTypeWithDefault_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SplitTypeWithDefault_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SplitTypeWithDefault_IsValid(int value);
constexpr SplitTypeWithDefault SplitTypeWithDefault_MIN = INEQUALITY_DEFAULT_LEFT;
constexpr SplitTypeWithDefault SplitTypeWithDefault_MAX = EQUALITY_DEFAULT_RIGHT;
constexpr int SplitTypeWithDefault_ARRAYSIZE = SplitTypeWithDefault_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SplitTypeWithDefault_descriptor();
template<typename T>
inline const std::string& SplitTypeWithDefault_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SplitTypeWithDefault>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SplitTypeWithDefault_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SplitTypeWithDefault_descriptor(), enum_t_value);
}
inline bool SplitTypeWithDefault_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SplitTypeWithDefault* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SplitTypeWithDefault>(
    SplitTypeWithDefault_descriptor(), name, value);
}
enum DefaultDirection : int {
  DEFAULT_LEFT = 0,
  DEFAULT_RIGHT = 1,
  DefaultDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DefaultDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DefaultDirection_IsValid(int value);
constexpr DefaultDirection DefaultDirection_MIN = DEFAULT_LEFT;
constexpr DefaultDirection DefaultDirection_MAX = DEFAULT_RIGHT;
constexpr int DefaultDirection_ARRAYSIZE = DefaultDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DefaultDirection_descriptor();
template<typename T>
inline const std::string& DefaultDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DefaultDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DefaultDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DefaultDirection_descriptor(), enum_t_value);
}
inline bool DefaultDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DefaultDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DefaultDirection>(
    DefaultDirection_descriptor(), name, value);
}
// ===================================================================

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit constexpr Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  enum NodeCase {
    kLeaf = 1,
    kBucketizedSplit = 2,
    kCategoricalSplit = 3,
    kDenseSplit = 4,
    NODE_NOT_SET = 0,
  };

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Node& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 777,
    kLeafFieldNumber = 1,
    kBucketizedSplitFieldNumber = 2,
    kCategoricalSplitFieldNumber = 3,
    kDenseSplitFieldNumber = 4,
  };
  // .tensorflow.boosted_trees.NodeMetadata metadata = 777;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::tensorflow::boosted_trees::NodeMetadata& metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::NodeMetadata* release_metadata();
  ::tensorflow::boosted_trees::NodeMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::boosted_trees::NodeMetadata* metadata);
  private:
  const ::tensorflow::boosted_trees::NodeMetadata& _internal_metadata() const;
  ::tensorflow::boosted_trees::NodeMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::tensorflow::boosted_trees::NodeMetadata* metadata);
  ::tensorflow::boosted_trees::NodeMetadata* unsafe_arena_release_metadata();

  // .tensorflow.boosted_trees.Leaf leaf = 1;
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::tensorflow::boosted_trees::Leaf& leaf() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::Leaf* release_leaf();
  ::tensorflow::boosted_trees::Leaf* mutable_leaf();
  void set_allocated_leaf(::tensorflow::boosted_trees::Leaf* leaf);
  private:
  const ::tensorflow::boosted_trees::Leaf& _internal_leaf() const;
  ::tensorflow::boosted_trees::Leaf* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::tensorflow::boosted_trees::Leaf* leaf);
  ::tensorflow::boosted_trees::Leaf* unsafe_arena_release_leaf();

  // .tensorflow.boosted_trees.BucketizedSplit bucketized_split = 2;
  bool has_bucketized_split() const;
  private:
  bool _internal_has_bucketized_split() const;
  public:
  void clear_bucketized_split();
  const ::tensorflow::boosted_trees::BucketizedSplit& bucketized_split() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::BucketizedSplit* release_bucketized_split();
  ::tensorflow::boosted_trees::BucketizedSplit* mutable_bucketized_split();
  void set_allocated_bucketized_split(::tensorflow::boosted_trees::BucketizedSplit* bucketized_split);
  private:
  const ::tensorflow::boosted_trees::BucketizedSplit& _internal_bucketized_split() const;
  ::tensorflow::boosted_trees::BucketizedSplit* _internal_mutable_bucketized_split();
  public:
  void unsafe_arena_set_allocated_bucketized_split(
      ::tensorflow::boosted_trees::BucketizedSplit* bucketized_split);
  ::tensorflow::boosted_trees::BucketizedSplit* unsafe_arena_release_bucketized_split();

  // .tensorflow.boosted_trees.CategoricalSplit categorical_split = 3;
  bool has_categorical_split() const;
  private:
  bool _internal_has_categorical_split() const;
  public:
  void clear_categorical_split();
  const ::tensorflow::boosted_trees::CategoricalSplit& categorical_split() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::CategoricalSplit* release_categorical_split();
  ::tensorflow::boosted_trees::CategoricalSplit* mutable_categorical_split();
  void set_allocated_categorical_split(::tensorflow::boosted_trees::CategoricalSplit* categorical_split);
  private:
  const ::tensorflow::boosted_trees::CategoricalSplit& _internal_categorical_split() const;
  ::tensorflow::boosted_trees::CategoricalSplit* _internal_mutable_categorical_split();
  public:
  void unsafe_arena_set_allocated_categorical_split(
      ::tensorflow::boosted_trees::CategoricalSplit* categorical_split);
  ::tensorflow::boosted_trees::CategoricalSplit* unsafe_arena_release_categorical_split();

  // .tensorflow.boosted_trees.DenseSplit dense_split = 4;
  bool has_dense_split() const;
  private:
  bool _internal_has_dense_split() const;
  public:
  void clear_dense_split();
  const ::tensorflow::boosted_trees::DenseSplit& dense_split() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::DenseSplit* release_dense_split();
  ::tensorflow::boosted_trees::DenseSplit* mutable_dense_split();
  void set_allocated_dense_split(::tensorflow::boosted_trees::DenseSplit* dense_split);
  private:
  const ::tensorflow::boosted_trees::DenseSplit& _internal_dense_split() const;
  ::tensorflow::boosted_trees::DenseSplit* _internal_mutable_dense_split();
  public:
  void unsafe_arena_set_allocated_dense_split(
      ::tensorflow::boosted_trees::DenseSplit* dense_split);
  ::tensorflow::boosted_trees::DenseSplit* unsafe_arena_release_dense_split();

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.Node)
 private:
  class _Internal;
  void set_has_leaf();
  void set_has_bucketized_split();
  void set_has_categorical_split();
  void set_has_dense_split();

  inline bool has_node() const;
  inline void clear_has_node();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::NodeMetadata* metadata_;
  union NodeUnion {
    constexpr NodeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tensorflow::boosted_trees::Leaf* leaf_;
    ::tensorflow::boosted_trees::BucketizedSplit* bucketized_split_;
    ::tensorflow::boosted_trees::CategoricalSplit* categorical_split_;
    ::tensorflow::boosted_trees::DenseSplit* dense_split_;
  } node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class NodeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.NodeMetadata) */ {
 public:
  inline NodeMetadata() : NodeMetadata(nullptr) {}
  ~NodeMetadata() override;
  explicit constexpr NodeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeMetadata(const NodeMetadata& from);
  NodeMetadata(NodeMetadata&& from) noexcept
    : NodeMetadata() {
    *this = ::std::move(from);
  }

  inline NodeMetadata& operator=(const NodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeMetadata& operator=(NodeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeMetadata* internal_default_instance() {
    return reinterpret_cast<const NodeMetadata*>(
               &_NodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeMetadata& a, NodeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.NodeMetadata";
  }
  protected:
  explicit NodeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalLeafFieldNumber = 2,
    kGainFieldNumber = 1,
  };
  // .tensorflow.boosted_trees.Leaf original_leaf = 2;
  bool has_original_leaf() const;
  private:
  bool _internal_has_original_leaf() const;
  public:
  void clear_original_leaf();
  const ::tensorflow::boosted_trees::Leaf& original_leaf() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::Leaf* release_original_leaf();
  ::tensorflow::boosted_trees::Leaf* mutable_original_leaf();
  void set_allocated_original_leaf(::tensorflow::boosted_trees::Leaf* original_leaf);
  private:
  const ::tensorflow::boosted_trees::Leaf& _internal_original_leaf() const;
  ::tensorflow::boosted_trees::Leaf* _internal_mutable_original_leaf();
  public:
  void unsafe_arena_set_allocated_original_leaf(
      ::tensorflow::boosted_trees::Leaf* original_leaf);
  ::tensorflow::boosted_trees::Leaf* unsafe_arena_release_original_leaf();

  // float gain = 1;
  void clear_gain();
  float gain() const;
  void set_gain(float value);
  private:
  float _internal_gain() const;
  void _internal_set_gain(float value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.NodeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::Leaf* original_leaf_;
  float gain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class Leaf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.Leaf) */ {
 public:
  inline Leaf() : Leaf(nullptr) {}
  ~Leaf() override;
  explicit constexpr Leaf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Leaf(const Leaf& from);
  Leaf(Leaf&& from) noexcept
    : Leaf() {
    *this = ::std::move(from);
  }

  inline Leaf& operator=(const Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Leaf& operator=(Leaf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Leaf& default_instance() {
    return *internal_default_instance();
  }
  enum LeafCase {
    kVector = 1,
    kSparseVector = 2,
    LEAF_NOT_SET = 0,
  };

  static inline const Leaf* internal_default_instance() {
    return reinterpret_cast<const Leaf*>(
               &_Leaf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Leaf& a, Leaf& b) {
    a.Swap(&b);
  }
  inline void Swap(Leaf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Leaf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Leaf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Leaf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Leaf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Leaf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Leaf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.Leaf";
  }
  protected:
  explicit Leaf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScalarFieldNumber = 3,
    kVectorFieldNumber = 1,
    kSparseVectorFieldNumber = 2,
  };
  // float scalar = 3;
  void clear_scalar();
  float scalar() const;
  void set_scalar(float value);
  private:
  float _internal_scalar() const;
  void _internal_set_scalar(float value);
  public:

  // .tensorflow.boosted_trees.Vector vector = 1;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;
  public:
  void clear_vector();
  const ::tensorflow::boosted_trees::Vector& vector() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::Vector* release_vector();
  ::tensorflow::boosted_trees::Vector* mutable_vector();
  void set_allocated_vector(::tensorflow::boosted_trees::Vector* vector);
  private:
  const ::tensorflow::boosted_trees::Vector& _internal_vector() const;
  ::tensorflow::boosted_trees::Vector* _internal_mutable_vector();
  public:
  void unsafe_arena_set_allocated_vector(
      ::tensorflow::boosted_trees::Vector* vector);
  ::tensorflow::boosted_trees::Vector* unsafe_arena_release_vector();

  // .tensorflow.boosted_trees.SparseVector sparse_vector = 2;
  bool has_sparse_vector() const;
  private:
  bool _internal_has_sparse_vector() const;
  public:
  void clear_sparse_vector();
  const ::tensorflow::boosted_trees::SparseVector& sparse_vector() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::SparseVector* release_sparse_vector();
  ::tensorflow::boosted_trees::SparseVector* mutable_sparse_vector();
  void set_allocated_sparse_vector(::tensorflow::boosted_trees::SparseVector* sparse_vector);
  private:
  const ::tensorflow::boosted_trees::SparseVector& _internal_sparse_vector() const;
  ::tensorflow::boosted_trees::SparseVector* _internal_mutable_sparse_vector();
  public:
  void unsafe_arena_set_allocated_sparse_vector(
      ::tensorflow::boosted_trees::SparseVector* sparse_vector);
  ::tensorflow::boosted_trees::SparseVector* unsafe_arena_release_sparse_vector();

  void clear_leaf();
  LeafCase leaf_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.Leaf)
 private:
  class _Internal;
  void set_has_vector();
  void set_has_sparse_vector();

  inline bool has_leaf() const;
  inline void clear_has_leaf();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float scalar_;
  union LeafUnion {
    constexpr LeafUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tensorflow::boosted_trees::Vector* vector_;
    ::tensorflow::boosted_trees::SparseVector* sparse_vector_;
  } leaf_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit constexpr Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated float value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class SparseVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.SparseVector) */ {
 public:
  inline SparseVector() : SparseVector(nullptr) {}
  ~SparseVector() override;
  explicit constexpr SparseVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SparseVector(const SparseVector& from);
  SparseVector(SparseVector&& from) noexcept
    : SparseVector() {
    *this = ::std::move(from);
  }

  inline SparseVector& operator=(const SparseVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseVector& operator=(SparseVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const SparseVector* internal_default_instance() {
    return reinterpret_cast<const SparseVector*>(
               &_SparseVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SparseVector& a, SparseVector& b) {
    a.Swap(&b);
  }
  inline void Swap(SparseVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SparseVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SparseVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SparseVector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.SparseVector";
  }
  protected:
  explicit SparseVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated int32 index = 1;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  int32_t _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_index() const;
  void _internal_add_index(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_index();
  public:
  int32_t index(int index) const;
  void set_index(int index, int32_t value);
  void add_index(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_index();

  // repeated float value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.SparseVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > index_;
  mutable std::atomic<int> _index_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class BucketizedSplit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.BucketizedSplit) */ {
 public:
  inline BucketizedSplit() : BucketizedSplit(nullptr) {}
  ~BucketizedSplit() override;
  explicit constexpr BucketizedSplit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketizedSplit(const BucketizedSplit& from);
  BucketizedSplit(BucketizedSplit&& from) noexcept
    : BucketizedSplit() {
    *this = ::std::move(from);
  }

  inline BucketizedSplit& operator=(const BucketizedSplit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketizedSplit& operator=(BucketizedSplit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketizedSplit& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketizedSplit* internal_default_instance() {
    return reinterpret_cast<const BucketizedSplit*>(
               &_BucketizedSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BucketizedSplit& a, BucketizedSplit& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketizedSplit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketizedSplit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BucketizedSplit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BucketizedSplit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketizedSplit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketizedSplit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketizedSplit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.BucketizedSplit";
  }
  protected:
  explicit BucketizedSplit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kThresholdFieldNumber = 2,
    kLeftIdFieldNumber = 3,
    kRightIdFieldNumber = 4,
    kDimensionIdFieldNumber = 5,
    kDefaultDirectionFieldNumber = 6,
  };
  // int32 feature_id = 1;
  void clear_feature_id();
  int32_t feature_id() const;
  void set_feature_id(int32_t value);
  private:
  int32_t _internal_feature_id() const;
  void _internal_set_feature_id(int32_t value);
  public:

  // int32 threshold = 2;
  void clear_threshold();
  int32_t threshold() const;
  void set_threshold(int32_t value);
  private:
  int32_t _internal_threshold() const;
  void _internal_set_threshold(int32_t value);
  public:

  // int32 left_id = 3;
  void clear_left_id();
  int32_t left_id() const;
  void set_left_id(int32_t value);
  private:
  int32_t _internal_left_id() const;
  void _internal_set_left_id(int32_t value);
  public:

  // int32 right_id = 4;
  void clear_right_id();
  int32_t right_id() const;
  void set_right_id(int32_t value);
  private:
  int32_t _internal_right_id() const;
  void _internal_set_right_id(int32_t value);
  public:

  // int32 dimension_id = 5;
  void clear_dimension_id();
  int32_t dimension_id() const;
  void set_dimension_id(int32_t value);
  private:
  int32_t _internal_dimension_id() const;
  void _internal_set_dimension_id(int32_t value);
  public:

  // .tensorflow.boosted_trees.DefaultDirection default_direction = 6;
  void clear_default_direction();
  ::tensorflow::boosted_trees::DefaultDirection default_direction() const;
  void set_default_direction(::tensorflow::boosted_trees::DefaultDirection value);
  private:
  ::tensorflow::boosted_trees::DefaultDirection _internal_default_direction() const;
  void _internal_set_default_direction(::tensorflow::boosted_trees::DefaultDirection value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.BucketizedSplit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t feature_id_;
  int32_t threshold_;
  int32_t left_id_;
  int32_t right_id_;
  int32_t dimension_id_;
  int default_direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class CategoricalSplit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.CategoricalSplit) */ {
 public:
  inline CategoricalSplit() : CategoricalSplit(nullptr) {}
  ~CategoricalSplit() override;
  explicit constexpr CategoricalSplit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CategoricalSplit(const CategoricalSplit& from);
  CategoricalSplit(CategoricalSplit&& from) noexcept
    : CategoricalSplit() {
    *this = ::std::move(from);
  }

  inline CategoricalSplit& operator=(const CategoricalSplit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CategoricalSplit& operator=(CategoricalSplit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CategoricalSplit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CategoricalSplit* internal_default_instance() {
    return reinterpret_cast<const CategoricalSplit*>(
               &_CategoricalSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CategoricalSplit& a, CategoricalSplit& b) {
    a.Swap(&b);
  }
  inline void Swap(CategoricalSplit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CategoricalSplit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CategoricalSplit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CategoricalSplit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CategoricalSplit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CategoricalSplit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CategoricalSplit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.CategoricalSplit";
  }
  protected:
  explicit CategoricalSplit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeftIdFieldNumber = 3,
    kRightIdFieldNumber = 4,
    kDimensionIdFieldNumber = 5,
  };
  // int32 feature_id = 1;
  void clear_feature_id();
  int32_t feature_id() const;
  void set_feature_id(int32_t value);
  private:
  int32_t _internal_feature_id() const;
  void _internal_set_feature_id(int32_t value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // int32 left_id = 3;
  void clear_left_id();
  int32_t left_id() const;
  void set_left_id(int32_t value);
  private:
  int32_t _internal_left_id() const;
  void _internal_set_left_id(int32_t value);
  public:

  // int32 right_id = 4;
  void clear_right_id();
  int32_t right_id() const;
  void set_right_id(int32_t value);
  private:
  int32_t _internal_right_id() const;
  void _internal_set_right_id(int32_t value);
  public:

  // int32 dimension_id = 5;
  void clear_dimension_id();
  int32_t dimension_id() const;
  void set_dimension_id(int32_t value);
  private:
  int32_t _internal_dimension_id() const;
  void _internal_set_dimension_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.CategoricalSplit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t feature_id_;
  int32_t value_;
  int32_t left_id_;
  int32_t right_id_;
  int32_t dimension_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class DenseSplit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.DenseSplit) */ {
 public:
  inline DenseSplit() : DenseSplit(nullptr) {}
  ~DenseSplit() override;
  explicit constexpr DenseSplit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenseSplit(const DenseSplit& from);
  DenseSplit(DenseSplit&& from) noexcept
    : DenseSplit() {
    *this = ::std::move(from);
  }

  inline DenseSplit& operator=(const DenseSplit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenseSplit& operator=(DenseSplit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenseSplit& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenseSplit* internal_default_instance() {
    return reinterpret_cast<const DenseSplit*>(
               &_DenseSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DenseSplit& a, DenseSplit& b) {
    a.Swap(&b);
  }
  inline void Swap(DenseSplit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenseSplit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenseSplit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenseSplit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenseSplit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DenseSplit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenseSplit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.DenseSplit";
  }
  protected:
  explicit DenseSplit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kThresholdFieldNumber = 2,
    kLeftIdFieldNumber = 3,
    kRightIdFieldNumber = 4,
  };
  // int32 feature_id = 1;
  void clear_feature_id();
  int32_t feature_id() const;
  void set_feature_id(int32_t value);
  private:
  int32_t _internal_feature_id() const;
  void _internal_set_feature_id(int32_t value);
  public:

  // float threshold = 2;
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);
  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);
  public:

  // int32 left_id = 3;
  void clear_left_id();
  int32_t left_id() const;
  void set_left_id(int32_t value);
  private:
  int32_t _internal_left_id() const;
  void _internal_set_left_id(int32_t value);
  public:

  // int32 right_id = 4;
  void clear_right_id();
  int32_t right_id() const;
  void set_right_id(int32_t value);
  private:
  int32_t _internal_right_id() const;
  void _internal_set_right_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.DenseSplit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t feature_id_;
  float threshold_;
  int32_t left_id_;
  int32_t right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class Tree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.Tree) */ {
 public:
  inline Tree() : Tree(nullptr) {}
  ~Tree() override;
  explicit constexpr Tree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tree(const Tree& from);
  Tree(Tree&& from) noexcept
    : Tree() {
    *this = ::std::move(from);
  }

  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tree& operator=(Tree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tree& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tree* internal_default_instance() {
    return reinterpret_cast<const Tree*>(
               &_Tree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Tree& a, Tree& b) {
    a.Swap(&b);
  }
  inline void Swap(Tree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tree& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.Tree";
  }
  protected:
  explicit Tree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .tensorflow.boosted_trees.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::tensorflow::boosted_trees::Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Node >*
      mutable_nodes();
  private:
  const ::tensorflow::boosted_trees::Node& _internal_nodes(int index) const;
  ::tensorflow::boosted_trees::Node* _internal_add_nodes();
  public:
  const ::tensorflow::boosted_trees::Node& nodes(int index) const;
  ::tensorflow::boosted_trees::Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.Tree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Node > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class TreeMetadata_PostPruneNodeUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate) */ {
 public:
  inline TreeMetadata_PostPruneNodeUpdate() : TreeMetadata_PostPruneNodeUpdate(nullptr) {}
  ~TreeMetadata_PostPruneNodeUpdate() override;
  explicit constexpr TreeMetadata_PostPruneNodeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreeMetadata_PostPruneNodeUpdate(const TreeMetadata_PostPruneNodeUpdate& from);
  TreeMetadata_PostPruneNodeUpdate(TreeMetadata_PostPruneNodeUpdate&& from) noexcept
    : TreeMetadata_PostPruneNodeUpdate() {
    *this = ::std::move(from);
  }

  inline TreeMetadata_PostPruneNodeUpdate& operator=(const TreeMetadata_PostPruneNodeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeMetadata_PostPruneNodeUpdate& operator=(TreeMetadata_PostPruneNodeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreeMetadata_PostPruneNodeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreeMetadata_PostPruneNodeUpdate* internal_default_instance() {
    return reinterpret_cast<const TreeMetadata_PostPruneNodeUpdate*>(
               &_TreeMetadata_PostPruneNodeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TreeMetadata_PostPruneNodeUpdate& a, TreeMetadata_PostPruneNodeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeMetadata_PostPruneNodeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeMetadata_PostPruneNodeUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeMetadata_PostPruneNodeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeMetadata_PostPruneNodeUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreeMetadata_PostPruneNodeUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TreeMetadata_PostPruneNodeUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeMetadata_PostPruneNodeUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate";
  }
  protected:
  explicit TreeMetadata_PostPruneNodeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogitChangeFieldNumber = 2,
    kNewNodeIdFieldNumber = 1,
  };
  // repeated float logit_change = 2;
  int logit_change_size() const;
  private:
  int _internal_logit_change_size() const;
  public:
  void clear_logit_change();
  private:
  float _internal_logit_change(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_logit_change() const;
  void _internal_add_logit_change(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_logit_change();
  public:
  float logit_change(int index) const;
  void set_logit_change(int index, float value);
  void add_logit_change(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      logit_change() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_logit_change();

  // int32 new_node_id = 1;
  void clear_new_node_id();
  int32_t new_node_id() const;
  void set_new_node_id(int32_t value);
  private:
  int32_t _internal_new_node_id() const;
  void _internal_set_new_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > logit_change_;
  int32_t new_node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class TreeMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.TreeMetadata) */ {
 public:
  inline TreeMetadata() : TreeMetadata(nullptr) {}
  ~TreeMetadata() override;
  explicit constexpr TreeMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreeMetadata(const TreeMetadata& from);
  TreeMetadata(TreeMetadata&& from) noexcept
    : TreeMetadata() {
    *this = ::std::move(from);
  }

  inline TreeMetadata& operator=(const TreeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeMetadata& operator=(TreeMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreeMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreeMetadata* internal_default_instance() {
    return reinterpret_cast<const TreeMetadata*>(
               &_TreeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TreeMetadata& a, TreeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreeMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TreeMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.TreeMetadata";
  }
  protected:
  explicit TreeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TreeMetadata_PostPruneNodeUpdate PostPruneNodeUpdate;

  // accessors -------------------------------------------------------

  enum : int {
    kPostPrunedNodesMetaFieldNumber = 4,
    kNumLayersGrownFieldNumber = 2,
    kIsFinalizedFieldNumber = 3,
  };
  // repeated .tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate post_pruned_nodes_meta = 4;
  int post_pruned_nodes_meta_size() const;
  private:
  int _internal_post_pruned_nodes_meta_size() const;
  public:
  void clear_post_pruned_nodes_meta();
  ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* mutable_post_pruned_nodes_meta(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate >*
      mutable_post_pruned_nodes_meta();
  private:
  const ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate& _internal_post_pruned_nodes_meta(int index) const;
  ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* _internal_add_post_pruned_nodes_meta();
  public:
  const ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate& post_pruned_nodes_meta(int index) const;
  ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* add_post_pruned_nodes_meta();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate >&
      post_pruned_nodes_meta() const;

  // int32 num_layers_grown = 2;
  void clear_num_layers_grown();
  int32_t num_layers_grown() const;
  void set_num_layers_grown(int32_t value);
  private:
  int32_t _internal_num_layers_grown() const;
  void _internal_set_num_layers_grown(int32_t value);
  public:

  // bool is_finalized = 3;
  void clear_is_finalized();
  bool is_finalized() const;
  void set_is_finalized(bool value);
  private:
  bool _internal_is_finalized() const;
  void _internal_set_is_finalized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.TreeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate > post_pruned_nodes_meta_;
  int32_t num_layers_grown_;
  bool is_finalized_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class GrowingMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.GrowingMetadata) */ {
 public:
  inline GrowingMetadata() : GrowingMetadata(nullptr) {}
  ~GrowingMetadata() override;
  explicit constexpr GrowingMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrowingMetadata(const GrowingMetadata& from);
  GrowingMetadata(GrowingMetadata&& from) noexcept
    : GrowingMetadata() {
    *this = ::std::move(from);
  }

  inline GrowingMetadata& operator=(const GrowingMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrowingMetadata& operator=(GrowingMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrowingMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrowingMetadata* internal_default_instance() {
    return reinterpret_cast<const GrowingMetadata*>(
               &_GrowingMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GrowingMetadata& a, GrowingMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(GrowingMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrowingMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrowingMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrowingMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrowingMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GrowingMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrowingMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.GrowingMetadata";
  }
  protected:
  explicit GrowingMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumTreesAttemptedFieldNumber = 1,
    kNumLayersAttemptedFieldNumber = 2,
    kLastLayerNodeStartFieldNumber = 3,
    kLastLayerNodeEndFieldNumber = 4,
  };
  // int64 num_trees_attempted = 1;
  void clear_num_trees_attempted();
  int64_t num_trees_attempted() const;
  void set_num_trees_attempted(int64_t value);
  private:
  int64_t _internal_num_trees_attempted() const;
  void _internal_set_num_trees_attempted(int64_t value);
  public:

  // int64 num_layers_attempted = 2;
  void clear_num_layers_attempted();
  int64_t num_layers_attempted() const;
  void set_num_layers_attempted(int64_t value);
  private:
  int64_t _internal_num_layers_attempted() const;
  void _internal_set_num_layers_attempted(int64_t value);
  public:

  // int32 last_layer_node_start = 3;
  void clear_last_layer_node_start();
  int32_t last_layer_node_start() const;
  void set_last_layer_node_start(int32_t value);
  private:
  int32_t _internal_last_layer_node_start() const;
  void _internal_set_last_layer_node_start(int32_t value);
  public:

  // int32 last_layer_node_end = 4;
  void clear_last_layer_node_end();
  int32_t last_layer_node_end() const;
  void set_last_layer_node_end(int32_t value);
  private:
  int32_t _internal_last_layer_node_end() const;
  void _internal_set_last_layer_node_end(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.GrowingMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t num_trees_attempted_;
  int64_t num_layers_attempted_;
  int32_t last_layer_node_start_;
  int32_t last_layer_node_end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class TreeEnsemble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.TreeEnsemble) */ {
 public:
  inline TreeEnsemble() : TreeEnsemble(nullptr) {}
  ~TreeEnsemble() override;
  explicit constexpr TreeEnsemble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreeEnsemble(const TreeEnsemble& from);
  TreeEnsemble(TreeEnsemble&& from) noexcept
    : TreeEnsemble() {
    *this = ::std::move(from);
  }

  inline TreeEnsemble& operator=(const TreeEnsemble& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeEnsemble& operator=(TreeEnsemble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreeEnsemble& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreeEnsemble* internal_default_instance() {
    return reinterpret_cast<const TreeEnsemble*>(
               &_TreeEnsemble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TreeEnsemble& a, TreeEnsemble& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeEnsemble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeEnsemble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeEnsemble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeEnsemble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreeEnsemble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TreeEnsemble& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeEnsemble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.TreeEnsemble";
  }
  protected:
  explicit TreeEnsemble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreesFieldNumber = 1,
    kTreeWeightsFieldNumber = 2,
    kTreeMetadataFieldNumber = 3,
    kGrowingMetadataFieldNumber = 4,
  };
  // repeated .tensorflow.boosted_trees.Tree trees = 1;
  int trees_size() const;
  private:
  int _internal_trees_size() const;
  public:
  void clear_trees();
  ::tensorflow::boosted_trees::Tree* mutable_trees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Tree >*
      mutable_trees();
  private:
  const ::tensorflow::boosted_trees::Tree& _internal_trees(int index) const;
  ::tensorflow::boosted_trees::Tree* _internal_add_trees();
  public:
  const ::tensorflow::boosted_trees::Tree& trees(int index) const;
  ::tensorflow::boosted_trees::Tree* add_trees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Tree >&
      trees() const;

  // repeated float tree_weights = 2;
  int tree_weights_size() const;
  private:
  int _internal_tree_weights_size() const;
  public:
  void clear_tree_weights();
  private:
  float _internal_tree_weights(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_tree_weights() const;
  void _internal_add_tree_weights(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_tree_weights();
  public:
  float tree_weights(int index) const;
  void set_tree_weights(int index, float value);
  void add_tree_weights(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      tree_weights() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_tree_weights();

  // repeated .tensorflow.boosted_trees.TreeMetadata tree_metadata = 3;
  int tree_metadata_size() const;
  private:
  int _internal_tree_metadata_size() const;
  public:
  void clear_tree_metadata();
  ::tensorflow::boosted_trees::TreeMetadata* mutable_tree_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata >*
      mutable_tree_metadata();
  private:
  const ::tensorflow::boosted_trees::TreeMetadata& _internal_tree_metadata(int index) const;
  ::tensorflow::boosted_trees::TreeMetadata* _internal_add_tree_metadata();
  public:
  const ::tensorflow::boosted_trees::TreeMetadata& tree_metadata(int index) const;
  ::tensorflow::boosted_trees::TreeMetadata* add_tree_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata >&
      tree_metadata() const;

  // .tensorflow.boosted_trees.GrowingMetadata growing_metadata = 4;
  bool has_growing_metadata() const;
  private:
  bool _internal_has_growing_metadata() const;
  public:
  void clear_growing_metadata();
  const ::tensorflow::boosted_trees::GrowingMetadata& growing_metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::boosted_trees::GrowingMetadata* release_growing_metadata();
  ::tensorflow::boosted_trees::GrowingMetadata* mutable_growing_metadata();
  void set_allocated_growing_metadata(::tensorflow::boosted_trees::GrowingMetadata* growing_metadata);
  private:
  const ::tensorflow::boosted_trees::GrowingMetadata& _internal_growing_metadata() const;
  ::tensorflow::boosted_trees::GrowingMetadata* _internal_mutable_growing_metadata();
  public:
  void unsafe_arena_set_allocated_growing_metadata(
      ::tensorflow::boosted_trees::GrowingMetadata* growing_metadata);
  ::tensorflow::boosted_trees::GrowingMetadata* unsafe_arena_release_growing_metadata();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.TreeEnsemble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Tree > trees_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > tree_weights_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata > tree_metadata_;
  ::tensorflow::boosted_trees::GrowingMetadata* growing_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// -------------------------------------------------------------------

class DebugOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.DebugOutput) */ {
 public:
  inline DebugOutput() : DebugOutput(nullptr) {}
  ~DebugOutput() override;
  explicit constexpr DebugOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugOutput(const DebugOutput& from);
  DebugOutput(DebugOutput&& from) noexcept
    : DebugOutput() {
    *this = ::std::move(from);
  }

  inline DebugOutput& operator=(const DebugOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugOutput& operator=(DebugOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugOutput* internal_default_instance() {
    return reinterpret_cast<const DebugOutput*>(
               &_DebugOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DebugOutput& a, DebugOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DebugOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.boosted_trees.DebugOutput";
  }
  protected:
  explicit DebugOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdsFieldNumber = 1,
    kLogitsPathFieldNumber = 2,
    kLeafNodeIdsFieldNumber = 3,
  };
  // repeated int32 feature_ids = 1;
  int feature_ids_size() const;
  private:
  int _internal_feature_ids_size() const;
  public:
  void clear_feature_ids();
  private:
  int32_t _internal_feature_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_feature_ids() const;
  void _internal_add_feature_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_feature_ids();
  public:
  int32_t feature_ids(int index) const;
  void set_feature_ids(int index, int32_t value);
  void add_feature_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      feature_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_feature_ids();

  // repeated float logits_path = 2;
  int logits_path_size() const;
  private:
  int _internal_logits_path_size() const;
  public:
  void clear_logits_path();
  private:
  float _internal_logits_path(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_logits_path() const;
  void _internal_add_logits_path(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_logits_path();
  public:
  float logits_path(int index) const;
  void set_logits_path(int index, float value);
  void add_logits_path(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      logits_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_logits_path();

  // repeated int32 leaf_node_ids = 3;
  int leaf_node_ids_size() const;
  private:
  int _internal_leaf_node_ids_size() const;
  public:
  void clear_leaf_node_ids();
  private:
  int32_t _internal_leaf_node_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_leaf_node_ids() const;
  void _internal_add_leaf_node_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_leaf_node_ids();
  public:
  int32_t leaf_node_ids(int index) const;
  void set_leaf_node_ids(int index, int32_t value);
  void add_leaf_node_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      leaf_node_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_leaf_node_ids();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.DebugOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > feature_ids_;
  mutable std::atomic<int> _feature_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > logits_path_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > leaf_node_ids_;
  mutable std::atomic<int> _leaf_node_ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Node

// .tensorflow.boosted_trees.Leaf leaf = 1;
inline bool Node::_internal_has_leaf() const {
  return node_case() == kLeaf;
}
inline bool Node::has_leaf() const {
  return _internal_has_leaf();
}
inline void Node::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void Node::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.leaf_;
    }
    clear_has_node();
  }
}
inline ::tensorflow::boosted_trees::Leaf* Node::release_leaf() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Node.leaf)
  if (_internal_has_leaf()) {
    clear_has_node();
      ::tensorflow::boosted_trees::Leaf* temp = node_.leaf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::Leaf& Node::_internal_leaf() const {
  return _internal_has_leaf()
      ? *node_.leaf_
      : reinterpret_cast< ::tensorflow::boosted_trees::Leaf&>(::tensorflow::boosted_trees::_Leaf_default_instance_);
}
inline const ::tensorflow::boosted_trees::Leaf& Node::leaf() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Node.leaf)
  return _internal_leaf();
}
inline ::tensorflow::boosted_trees::Leaf* Node::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Node.leaf)
  if (_internal_has_leaf()) {
    clear_has_node();
    ::tensorflow::boosted_trees::Leaf* temp = node_.leaf_;
    node_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_leaf(::tensorflow::boosted_trees::Leaf* leaf) {
  clear_node();
  if (leaf) {
    set_has_leaf();
    node_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Node.leaf)
}
inline ::tensorflow::boosted_trees::Leaf* Node::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_node();
    set_has_leaf();
    node_.leaf_ = CreateMaybeMessage< ::tensorflow::boosted_trees::Leaf >(GetArenaForAllocation());
  }
  return node_.leaf_;
}
inline ::tensorflow::boosted_trees::Leaf* Node::mutable_leaf() {
  ::tensorflow::boosted_trees::Leaf* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Node.leaf)
  return _msg;
}

// .tensorflow.boosted_trees.BucketizedSplit bucketized_split = 2;
inline bool Node::_internal_has_bucketized_split() const {
  return node_case() == kBucketizedSplit;
}
inline bool Node::has_bucketized_split() const {
  return _internal_has_bucketized_split();
}
inline void Node::set_has_bucketized_split() {
  _oneof_case_[0] = kBucketizedSplit;
}
inline void Node::clear_bucketized_split() {
  if (_internal_has_bucketized_split()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.bucketized_split_;
    }
    clear_has_node();
  }
}
inline ::tensorflow::boosted_trees::BucketizedSplit* Node::release_bucketized_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Node.bucketized_split)
  if (_internal_has_bucketized_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::BucketizedSplit* temp = node_.bucketized_split_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.bucketized_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::BucketizedSplit& Node::_internal_bucketized_split() const {
  return _internal_has_bucketized_split()
      ? *node_.bucketized_split_
      : reinterpret_cast< ::tensorflow::boosted_trees::BucketizedSplit&>(::tensorflow::boosted_trees::_BucketizedSplit_default_instance_);
}
inline const ::tensorflow::boosted_trees::BucketizedSplit& Node::bucketized_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Node.bucketized_split)
  return _internal_bucketized_split();
}
inline ::tensorflow::boosted_trees::BucketizedSplit* Node::unsafe_arena_release_bucketized_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Node.bucketized_split)
  if (_internal_has_bucketized_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::BucketizedSplit* temp = node_.bucketized_split_;
    node_.bucketized_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_bucketized_split(::tensorflow::boosted_trees::BucketizedSplit* bucketized_split) {
  clear_node();
  if (bucketized_split) {
    set_has_bucketized_split();
    node_.bucketized_split_ = bucketized_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Node.bucketized_split)
}
inline ::tensorflow::boosted_trees::BucketizedSplit* Node::_internal_mutable_bucketized_split() {
  if (!_internal_has_bucketized_split()) {
    clear_node();
    set_has_bucketized_split();
    node_.bucketized_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::BucketizedSplit >(GetArenaForAllocation());
  }
  return node_.bucketized_split_;
}
inline ::tensorflow::boosted_trees::BucketizedSplit* Node::mutable_bucketized_split() {
  ::tensorflow::boosted_trees::BucketizedSplit* _msg = _internal_mutable_bucketized_split();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Node.bucketized_split)
  return _msg;
}

// .tensorflow.boosted_trees.CategoricalSplit categorical_split = 3;
inline bool Node::_internal_has_categorical_split() const {
  return node_case() == kCategoricalSplit;
}
inline bool Node::has_categorical_split() const {
  return _internal_has_categorical_split();
}
inline void Node::set_has_categorical_split() {
  _oneof_case_[0] = kCategoricalSplit;
}
inline void Node::clear_categorical_split() {
  if (_internal_has_categorical_split()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.categorical_split_;
    }
    clear_has_node();
  }
}
inline ::tensorflow::boosted_trees::CategoricalSplit* Node::release_categorical_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Node.categorical_split)
  if (_internal_has_categorical_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::CategoricalSplit* temp = node_.categorical_split_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.categorical_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::CategoricalSplit& Node::_internal_categorical_split() const {
  return _internal_has_categorical_split()
      ? *node_.categorical_split_
      : reinterpret_cast< ::tensorflow::boosted_trees::CategoricalSplit&>(::tensorflow::boosted_trees::_CategoricalSplit_default_instance_);
}
inline const ::tensorflow::boosted_trees::CategoricalSplit& Node::categorical_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Node.categorical_split)
  return _internal_categorical_split();
}
inline ::tensorflow::boosted_trees::CategoricalSplit* Node::unsafe_arena_release_categorical_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Node.categorical_split)
  if (_internal_has_categorical_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::CategoricalSplit* temp = node_.categorical_split_;
    node_.categorical_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_categorical_split(::tensorflow::boosted_trees::CategoricalSplit* categorical_split) {
  clear_node();
  if (categorical_split) {
    set_has_categorical_split();
    node_.categorical_split_ = categorical_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Node.categorical_split)
}
inline ::tensorflow::boosted_trees::CategoricalSplit* Node::_internal_mutable_categorical_split() {
  if (!_internal_has_categorical_split()) {
    clear_node();
    set_has_categorical_split();
    node_.categorical_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::CategoricalSplit >(GetArenaForAllocation());
  }
  return node_.categorical_split_;
}
inline ::tensorflow::boosted_trees::CategoricalSplit* Node::mutable_categorical_split() {
  ::tensorflow::boosted_trees::CategoricalSplit* _msg = _internal_mutable_categorical_split();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Node.categorical_split)
  return _msg;
}

// .tensorflow.boosted_trees.DenseSplit dense_split = 4;
inline bool Node::_internal_has_dense_split() const {
  return node_case() == kDenseSplit;
}
inline bool Node::has_dense_split() const {
  return _internal_has_dense_split();
}
inline void Node::set_has_dense_split() {
  _oneof_case_[0] = kDenseSplit;
}
inline void Node::clear_dense_split() {
  if (_internal_has_dense_split()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.dense_split_;
    }
    clear_has_node();
  }
}
inline ::tensorflow::boosted_trees::DenseSplit* Node::release_dense_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Node.dense_split)
  if (_internal_has_dense_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::DenseSplit* temp = node_.dense_split_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.dense_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::DenseSplit& Node::_internal_dense_split() const {
  return _internal_has_dense_split()
      ? *node_.dense_split_
      : reinterpret_cast< ::tensorflow::boosted_trees::DenseSplit&>(::tensorflow::boosted_trees::_DenseSplit_default_instance_);
}
inline const ::tensorflow::boosted_trees::DenseSplit& Node::dense_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Node.dense_split)
  return _internal_dense_split();
}
inline ::tensorflow::boosted_trees::DenseSplit* Node::unsafe_arena_release_dense_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Node.dense_split)
  if (_internal_has_dense_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::DenseSplit* temp = node_.dense_split_;
    node_.dense_split_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_dense_split(::tensorflow::boosted_trees::DenseSplit* dense_split) {
  clear_node();
  if (dense_split) {
    set_has_dense_split();
    node_.dense_split_ = dense_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Node.dense_split)
}
inline ::tensorflow::boosted_trees::DenseSplit* Node::_internal_mutable_dense_split() {
  if (!_internal_has_dense_split()) {
    clear_node();
    set_has_dense_split();
    node_.dense_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::DenseSplit >(GetArenaForAllocation());
  }
  return node_.dense_split_;
}
inline ::tensorflow::boosted_trees::DenseSplit* Node::mutable_dense_split() {
  ::tensorflow::boosted_trees::DenseSplit* _msg = _internal_mutable_dense_split();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Node.dense_split)
  return _msg;
}

// .tensorflow.boosted_trees.NodeMetadata metadata = 777;
inline bool Node::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Node::has_metadata() const {
  return _internal_has_metadata();
}
inline void Node::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::tensorflow::boosted_trees::NodeMetadata& Node::_internal_metadata() const {
  const ::tensorflow::boosted_trees::NodeMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::boosted_trees::NodeMetadata&>(
      ::tensorflow::boosted_trees::_NodeMetadata_default_instance_);
}
inline const ::tensorflow::boosted_trees::NodeMetadata& Node::metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Node.metadata)
  return _internal_metadata();
}
inline void Node::unsafe_arena_set_allocated_metadata(
    ::tensorflow::boosted_trees::NodeMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Node.metadata)
}
inline ::tensorflow::boosted_trees::NodeMetadata* Node::release_metadata() {
  
  ::tensorflow::boosted_trees::NodeMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::boosted_trees::NodeMetadata* Node::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Node.metadata)
  
  ::tensorflow::boosted_trees::NodeMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::tensorflow::boosted_trees::NodeMetadata* Node::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::NodeMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::tensorflow::boosted_trees::NodeMetadata* Node::mutable_metadata() {
  ::tensorflow::boosted_trees::NodeMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Node.metadata)
  return _msg;
}
inline void Node::set_allocated_metadata(::tensorflow::boosted_trees::NodeMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tensorflow::boosted_trees::NodeMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.Node.metadata)
}

inline bool Node::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void Node::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline Node::NodeCase Node::node_case() const {
  return Node::NodeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeMetadata

// float gain = 1;
inline void NodeMetadata::clear_gain() {
  gain_ = 0;
}
inline float NodeMetadata::_internal_gain() const {
  return gain_;
}
inline float NodeMetadata::gain() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.NodeMetadata.gain)
  return _internal_gain();
}
inline void NodeMetadata::_internal_set_gain(float value) {
  
  gain_ = value;
}
inline void NodeMetadata::set_gain(float value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.NodeMetadata.gain)
}

// .tensorflow.boosted_trees.Leaf original_leaf = 2;
inline bool NodeMetadata::_internal_has_original_leaf() const {
  return this != internal_default_instance() && original_leaf_ != nullptr;
}
inline bool NodeMetadata::has_original_leaf() const {
  return _internal_has_original_leaf();
}
inline void NodeMetadata::clear_original_leaf() {
  if (GetArenaForAllocation() == nullptr && original_leaf_ != nullptr) {
    delete original_leaf_;
  }
  original_leaf_ = nullptr;
}
inline const ::tensorflow::boosted_trees::Leaf& NodeMetadata::_internal_original_leaf() const {
  const ::tensorflow::boosted_trees::Leaf* p = original_leaf_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::boosted_trees::Leaf&>(
      ::tensorflow::boosted_trees::_Leaf_default_instance_);
}
inline const ::tensorflow::boosted_trees::Leaf& NodeMetadata::original_leaf() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.NodeMetadata.original_leaf)
  return _internal_original_leaf();
}
inline void NodeMetadata::unsafe_arena_set_allocated_original_leaf(
    ::tensorflow::boosted_trees::Leaf* original_leaf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_leaf_);
  }
  original_leaf_ = original_leaf;
  if (original_leaf) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.NodeMetadata.original_leaf)
}
inline ::tensorflow::boosted_trees::Leaf* NodeMetadata::release_original_leaf() {
  
  ::tensorflow::boosted_trees::Leaf* temp = original_leaf_;
  original_leaf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::boosted_trees::Leaf* NodeMetadata::unsafe_arena_release_original_leaf() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.NodeMetadata.original_leaf)
  
  ::tensorflow::boosted_trees::Leaf* temp = original_leaf_;
  original_leaf_ = nullptr;
  return temp;
}
inline ::tensorflow::boosted_trees::Leaf* NodeMetadata::_internal_mutable_original_leaf() {
  
  if (original_leaf_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::Leaf>(GetArenaForAllocation());
    original_leaf_ = p;
  }
  return original_leaf_;
}
inline ::tensorflow::boosted_trees::Leaf* NodeMetadata::mutable_original_leaf() {
  ::tensorflow::boosted_trees::Leaf* _msg = _internal_mutable_original_leaf();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.NodeMetadata.original_leaf)
  return _msg;
}
inline void NodeMetadata::set_allocated_original_leaf(::tensorflow::boosted_trees::Leaf* original_leaf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete original_leaf_;
  }
  if (original_leaf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tensorflow::boosted_trees::Leaf>::GetOwningArena(original_leaf);
    if (message_arena != submessage_arena) {
      original_leaf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_leaf, submessage_arena);
    }
    
  } else {
    
  }
  original_leaf_ = original_leaf;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.NodeMetadata.original_leaf)
}

// -------------------------------------------------------------------

// Leaf

// .tensorflow.boosted_trees.Vector vector = 1;
inline bool Leaf::_internal_has_vector() const {
  return leaf_case() == kVector;
}
inline bool Leaf::has_vector() const {
  return _internal_has_vector();
}
inline void Leaf::set_has_vector() {
  _oneof_case_[0] = kVector;
}
inline void Leaf::clear_vector() {
  if (_internal_has_vector()) {
    if (GetArenaForAllocation() == nullptr) {
      delete leaf_.vector_;
    }
    clear_has_leaf();
  }
}
inline ::tensorflow::boosted_trees::Vector* Leaf::release_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Leaf.vector)
  if (_internal_has_vector()) {
    clear_has_leaf();
      ::tensorflow::boosted_trees::Vector* temp = leaf_.vector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::Vector& Leaf::_internal_vector() const {
  return _internal_has_vector()
      ? *leaf_.vector_
      : reinterpret_cast< ::tensorflow::boosted_trees::Vector&>(::tensorflow::boosted_trees::_Vector_default_instance_);
}
inline const ::tensorflow::boosted_trees::Vector& Leaf::vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Leaf.vector)
  return _internal_vector();
}
inline ::tensorflow::boosted_trees::Vector* Leaf::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Leaf.vector)
  if (_internal_has_vector()) {
    clear_has_leaf();
    ::tensorflow::boosted_trees::Vector* temp = leaf_.vector_;
    leaf_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Leaf::unsafe_arena_set_allocated_vector(::tensorflow::boosted_trees::Vector* vector) {
  clear_leaf();
  if (vector) {
    set_has_vector();
    leaf_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Leaf.vector)
}
inline ::tensorflow::boosted_trees::Vector* Leaf::_internal_mutable_vector() {
  if (!_internal_has_vector()) {
    clear_leaf();
    set_has_vector();
    leaf_.vector_ = CreateMaybeMessage< ::tensorflow::boosted_trees::Vector >(GetArenaForAllocation());
  }
  return leaf_.vector_;
}
inline ::tensorflow::boosted_trees::Vector* Leaf::mutable_vector() {
  ::tensorflow::boosted_trees::Vector* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Leaf.vector)
  return _msg;
}

// .tensorflow.boosted_trees.SparseVector sparse_vector = 2;
inline bool Leaf::_internal_has_sparse_vector() const {
  return leaf_case() == kSparseVector;
}
inline bool Leaf::has_sparse_vector() const {
  return _internal_has_sparse_vector();
}
inline void Leaf::set_has_sparse_vector() {
  _oneof_case_[0] = kSparseVector;
}
inline void Leaf::clear_sparse_vector() {
  if (_internal_has_sparse_vector()) {
    if (GetArenaForAllocation() == nullptr) {
      delete leaf_.sparse_vector_;
    }
    clear_has_leaf();
  }
}
inline ::tensorflow::boosted_trees::SparseVector* Leaf::release_sparse_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.Leaf.sparse_vector)
  if (_internal_has_sparse_vector()) {
    clear_has_leaf();
      ::tensorflow::boosted_trees::SparseVector* temp = leaf_.sparse_vector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_.sparse_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::boosted_trees::SparseVector& Leaf::_internal_sparse_vector() const {
  return _internal_has_sparse_vector()
      ? *leaf_.sparse_vector_
      : reinterpret_cast< ::tensorflow::boosted_trees::SparseVector&>(::tensorflow::boosted_trees::_SparseVector_default_instance_);
}
inline const ::tensorflow::boosted_trees::SparseVector& Leaf::sparse_vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Leaf.sparse_vector)
  return _internal_sparse_vector();
}
inline ::tensorflow::boosted_trees::SparseVector* Leaf::unsafe_arena_release_sparse_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.Leaf.sparse_vector)
  if (_internal_has_sparse_vector()) {
    clear_has_leaf();
    ::tensorflow::boosted_trees::SparseVector* temp = leaf_.sparse_vector_;
    leaf_.sparse_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Leaf::unsafe_arena_set_allocated_sparse_vector(::tensorflow::boosted_trees::SparseVector* sparse_vector) {
  clear_leaf();
  if (sparse_vector) {
    set_has_sparse_vector();
    leaf_.sparse_vector_ = sparse_vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.Leaf.sparse_vector)
}
inline ::tensorflow::boosted_trees::SparseVector* Leaf::_internal_mutable_sparse_vector() {
  if (!_internal_has_sparse_vector()) {
    clear_leaf();
    set_has_sparse_vector();
    leaf_.sparse_vector_ = CreateMaybeMessage< ::tensorflow::boosted_trees::SparseVector >(GetArenaForAllocation());
  }
  return leaf_.sparse_vector_;
}
inline ::tensorflow::boosted_trees::SparseVector* Leaf::mutable_sparse_vector() {
  ::tensorflow::boosted_trees::SparseVector* _msg = _internal_mutable_sparse_vector();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Leaf.sparse_vector)
  return _msg;
}

// float scalar = 3;
inline void Leaf::clear_scalar() {
  scalar_ = 0;
}
inline float Leaf::_internal_scalar() const {
  return scalar_;
}
inline float Leaf::scalar() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Leaf.scalar)
  return _internal_scalar();
}
inline void Leaf::_internal_set_scalar(float value) {
  
  scalar_ = value;
}
inline void Leaf::set_scalar(float value) {
  _internal_set_scalar(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.Leaf.scalar)
}

inline bool Leaf::has_leaf() const {
  return leaf_case() != LEAF_NOT_SET;
}
inline void Leaf::clear_has_leaf() {
  _oneof_case_[0] = LEAF_NOT_SET;
}
inline Leaf::LeafCase Leaf::leaf_case() const {
  return Leaf::LeafCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vector

// repeated float value = 1;
inline int Vector::_internal_value_size() const {
  return value_.size();
}
inline int Vector::value_size() const {
  return _internal_value_size();
}
inline void Vector::clear_value() {
  value_.Clear();
}
inline float Vector::_internal_value(int index) const {
  return value_.Get(index);
}
inline float Vector::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Vector.value)
  return _internal_value(index);
}
inline void Vector::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.Vector.value)
}
inline void Vector::_internal_add_value(float value) {
  value_.Add(value);
}
inline void Vector::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.Vector.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Vector::_internal_value() const {
  return value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Vector::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.Vector.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Vector::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Vector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.Vector.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// SparseVector

// repeated int32 index = 1;
inline int SparseVector::_internal_index_size() const {
  return index_.size();
}
inline int SparseVector::index_size() const {
  return _internal_index_size();
}
inline void SparseVector::clear_index() {
  index_.Clear();
}
inline int32_t SparseVector::_internal_index(int index) const {
  return index_.Get(index);
}
inline int32_t SparseVector::index(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.SparseVector.index)
  return _internal_index(index);
}
inline void SparseVector::set_index(int index, int32_t value) {
  index_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.SparseVector.index)
}
inline void SparseVector::_internal_add_index(int32_t value) {
  index_.Add(value);
}
inline void SparseVector::add_index(int32_t value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.SparseVector.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SparseVector::_internal_index() const {
  return index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SparseVector::index() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.SparseVector.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SparseVector::_internal_mutable_index() {
  return &index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SparseVector::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.SparseVector.index)
  return _internal_mutable_index();
}

// repeated float value = 2;
inline int SparseVector::_internal_value_size() const {
  return value_.size();
}
inline int SparseVector::value_size() const {
  return _internal_value_size();
}
inline void SparseVector::clear_value() {
  value_.Clear();
}
inline float SparseVector::_internal_value(int index) const {
  return value_.Get(index);
}
inline float SparseVector::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.SparseVector.value)
  return _internal_value(index);
}
inline void SparseVector::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.SparseVector.value)
}
inline void SparseVector::_internal_add_value(float value) {
  value_.Add(value);
}
inline void SparseVector::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.SparseVector.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SparseVector::_internal_value() const {
  return value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SparseVector::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.SparseVector.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SparseVector::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SparseVector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.SparseVector.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// BucketizedSplit

// int32 feature_id = 1;
inline void BucketizedSplit::clear_feature_id() {
  feature_id_ = 0;
}
inline int32_t BucketizedSplit::_internal_feature_id() const {
  return feature_id_;
}
inline int32_t BucketizedSplit::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.feature_id)
  return _internal_feature_id();
}
inline void BucketizedSplit::_internal_set_feature_id(int32_t value) {
  
  feature_id_ = value;
}
inline void BucketizedSplit::set_feature_id(int32_t value) {
  _internal_set_feature_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.feature_id)
}

// int32 threshold = 2;
inline void BucketizedSplit::clear_threshold() {
  threshold_ = 0;
}
inline int32_t BucketizedSplit::_internal_threshold() const {
  return threshold_;
}
inline int32_t BucketizedSplit::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.threshold)
  return _internal_threshold();
}
inline void BucketizedSplit::_internal_set_threshold(int32_t value) {
  
  threshold_ = value;
}
inline void BucketizedSplit::set_threshold(int32_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.threshold)
}

// int32 dimension_id = 5;
inline void BucketizedSplit::clear_dimension_id() {
  dimension_id_ = 0;
}
inline int32_t BucketizedSplit::_internal_dimension_id() const {
  return dimension_id_;
}
inline int32_t BucketizedSplit::dimension_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.dimension_id)
  return _internal_dimension_id();
}
inline void BucketizedSplit::_internal_set_dimension_id(int32_t value) {
  
  dimension_id_ = value;
}
inline void BucketizedSplit::set_dimension_id(int32_t value) {
  _internal_set_dimension_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.dimension_id)
}

// .tensorflow.boosted_trees.DefaultDirection default_direction = 6;
inline void BucketizedSplit::clear_default_direction() {
  default_direction_ = 0;
}
inline ::tensorflow::boosted_trees::DefaultDirection BucketizedSplit::_internal_default_direction() const {
  return static_cast< ::tensorflow::boosted_trees::DefaultDirection >(default_direction_);
}
inline ::tensorflow::boosted_trees::DefaultDirection BucketizedSplit::default_direction() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.default_direction)
  return _internal_default_direction();
}
inline void BucketizedSplit::_internal_set_default_direction(::tensorflow::boosted_trees::DefaultDirection value) {
  
  default_direction_ = value;
}
inline void BucketizedSplit::set_default_direction(::tensorflow::boosted_trees::DefaultDirection value) {
  _internal_set_default_direction(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.default_direction)
}

// int32 left_id = 3;
inline void BucketizedSplit::clear_left_id() {
  left_id_ = 0;
}
inline int32_t BucketizedSplit::_internal_left_id() const {
  return left_id_;
}
inline int32_t BucketizedSplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.left_id)
  return _internal_left_id();
}
inline void BucketizedSplit::_internal_set_left_id(int32_t value) {
  
  left_id_ = value;
}
inline void BucketizedSplit::set_left_id(int32_t value) {
  _internal_set_left_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.left_id)
}

// int32 right_id = 4;
inline void BucketizedSplit::clear_right_id() {
  right_id_ = 0;
}
inline int32_t BucketizedSplit::_internal_right_id() const {
  return right_id_;
}
inline int32_t BucketizedSplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.BucketizedSplit.right_id)
  return _internal_right_id();
}
inline void BucketizedSplit::_internal_set_right_id(int32_t value) {
  
  right_id_ = value;
}
inline void BucketizedSplit::set_right_id(int32_t value) {
  _internal_set_right_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.BucketizedSplit.right_id)
}

// -------------------------------------------------------------------

// CategoricalSplit

// int32 feature_id = 1;
inline void CategoricalSplit::clear_feature_id() {
  feature_id_ = 0;
}
inline int32_t CategoricalSplit::_internal_feature_id() const {
  return feature_id_;
}
inline int32_t CategoricalSplit::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.CategoricalSplit.feature_id)
  return _internal_feature_id();
}
inline void CategoricalSplit::_internal_set_feature_id(int32_t value) {
  
  feature_id_ = value;
}
inline void CategoricalSplit::set_feature_id(int32_t value) {
  _internal_set_feature_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.CategoricalSplit.feature_id)
}

// int32 value = 2;
inline void CategoricalSplit::clear_value() {
  value_ = 0;
}
inline int32_t CategoricalSplit::_internal_value() const {
  return value_;
}
inline int32_t CategoricalSplit::value() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.CategoricalSplit.value)
  return _internal_value();
}
inline void CategoricalSplit::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void CategoricalSplit::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.CategoricalSplit.value)
}

// int32 dimension_id = 5;
inline void CategoricalSplit::clear_dimension_id() {
  dimension_id_ = 0;
}
inline int32_t CategoricalSplit::_internal_dimension_id() const {
  return dimension_id_;
}
inline int32_t CategoricalSplit::dimension_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.CategoricalSplit.dimension_id)
  return _internal_dimension_id();
}
inline void CategoricalSplit::_internal_set_dimension_id(int32_t value) {
  
  dimension_id_ = value;
}
inline void CategoricalSplit::set_dimension_id(int32_t value) {
  _internal_set_dimension_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.CategoricalSplit.dimension_id)
}

// int32 left_id = 3;
inline void CategoricalSplit::clear_left_id() {
  left_id_ = 0;
}
inline int32_t CategoricalSplit::_internal_left_id() const {
  return left_id_;
}
inline int32_t CategoricalSplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.CategoricalSplit.left_id)
  return _internal_left_id();
}
inline void CategoricalSplit::_internal_set_left_id(int32_t value) {
  
  left_id_ = value;
}
inline void CategoricalSplit::set_left_id(int32_t value) {
  _internal_set_left_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.CategoricalSplit.left_id)
}

// int32 right_id = 4;
inline void CategoricalSplit::clear_right_id() {
  right_id_ = 0;
}
inline int32_t CategoricalSplit::_internal_right_id() const {
  return right_id_;
}
inline int32_t CategoricalSplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.CategoricalSplit.right_id)
  return _internal_right_id();
}
inline void CategoricalSplit::_internal_set_right_id(int32_t value) {
  
  right_id_ = value;
}
inline void CategoricalSplit::set_right_id(int32_t value) {
  _internal_set_right_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.CategoricalSplit.right_id)
}

// -------------------------------------------------------------------

// DenseSplit

// int32 feature_id = 1;
inline void DenseSplit::clear_feature_id() {
  feature_id_ = 0;
}
inline int32_t DenseSplit::_internal_feature_id() const {
  return feature_id_;
}
inline int32_t DenseSplit::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DenseSplit.feature_id)
  return _internal_feature_id();
}
inline void DenseSplit::_internal_set_feature_id(int32_t value) {
  
  feature_id_ = value;
}
inline void DenseSplit::set_feature_id(int32_t value) {
  _internal_set_feature_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DenseSplit.feature_id)
}

// float threshold = 2;
inline void DenseSplit::clear_threshold() {
  threshold_ = 0;
}
inline float DenseSplit::_internal_threshold() const {
  return threshold_;
}
inline float DenseSplit::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DenseSplit.threshold)
  return _internal_threshold();
}
inline void DenseSplit::_internal_set_threshold(float value) {
  
  threshold_ = value;
}
inline void DenseSplit::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DenseSplit.threshold)
}

// int32 left_id = 3;
inline void DenseSplit::clear_left_id() {
  left_id_ = 0;
}
inline int32_t DenseSplit::_internal_left_id() const {
  return left_id_;
}
inline int32_t DenseSplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DenseSplit.left_id)
  return _internal_left_id();
}
inline void DenseSplit::_internal_set_left_id(int32_t value) {
  
  left_id_ = value;
}
inline void DenseSplit::set_left_id(int32_t value) {
  _internal_set_left_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DenseSplit.left_id)
}

// int32 right_id = 4;
inline void DenseSplit::clear_right_id() {
  right_id_ = 0;
}
inline int32_t DenseSplit::_internal_right_id() const {
  return right_id_;
}
inline int32_t DenseSplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DenseSplit.right_id)
  return _internal_right_id();
}
inline void DenseSplit::_internal_set_right_id(int32_t value) {
  
  right_id_ = value;
}
inline void DenseSplit::set_right_id(int32_t value) {
  _internal_set_right_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DenseSplit.right_id)
}

// -------------------------------------------------------------------

// Tree

// repeated .tensorflow.boosted_trees.Node nodes = 1;
inline int Tree::_internal_nodes_size() const {
  return nodes_.size();
}
inline int Tree::nodes_size() const {
  return _internal_nodes_size();
}
inline void Tree::clear_nodes() {
  nodes_.Clear();
}
inline ::tensorflow::boosted_trees::Node* Tree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.Tree.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Node >*
Tree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.Tree.nodes)
  return &nodes_;
}
inline const ::tensorflow::boosted_trees::Node& Tree::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::tensorflow::boosted_trees::Node& Tree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.Tree.nodes)
  return _internal_nodes(index);
}
inline ::tensorflow::boosted_trees::Node* Tree::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::tensorflow::boosted_trees::Node* Tree::add_nodes() {
  ::tensorflow::boosted_trees::Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.Tree.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Node >&
Tree::nodes() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.Tree.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// TreeMetadata_PostPruneNodeUpdate

// int32 new_node_id = 1;
inline void TreeMetadata_PostPruneNodeUpdate::clear_new_node_id() {
  new_node_id_ = 0;
}
inline int32_t TreeMetadata_PostPruneNodeUpdate::_internal_new_node_id() const {
  return new_node_id_;
}
inline int32_t TreeMetadata_PostPruneNodeUpdate::new_node_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.new_node_id)
  return _internal_new_node_id();
}
inline void TreeMetadata_PostPruneNodeUpdate::_internal_set_new_node_id(int32_t value) {
  
  new_node_id_ = value;
}
inline void TreeMetadata_PostPruneNodeUpdate::set_new_node_id(int32_t value) {
  _internal_set_new_node_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.new_node_id)
}

// repeated float logit_change = 2;
inline int TreeMetadata_PostPruneNodeUpdate::_internal_logit_change_size() const {
  return logit_change_.size();
}
inline int TreeMetadata_PostPruneNodeUpdate::logit_change_size() const {
  return _internal_logit_change_size();
}
inline void TreeMetadata_PostPruneNodeUpdate::clear_logit_change() {
  logit_change_.Clear();
}
inline float TreeMetadata_PostPruneNodeUpdate::_internal_logit_change(int index) const {
  return logit_change_.Get(index);
}
inline float TreeMetadata_PostPruneNodeUpdate::logit_change(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.logit_change)
  return _internal_logit_change(index);
}
inline void TreeMetadata_PostPruneNodeUpdate::set_logit_change(int index, float value) {
  logit_change_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.logit_change)
}
inline void TreeMetadata_PostPruneNodeUpdate::_internal_add_logit_change(float value) {
  logit_change_.Add(value);
}
inline void TreeMetadata_PostPruneNodeUpdate::add_logit_change(float value) {
  _internal_add_logit_change(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.logit_change)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TreeMetadata_PostPruneNodeUpdate::_internal_logit_change() const {
  return logit_change_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TreeMetadata_PostPruneNodeUpdate::logit_change() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.logit_change)
  return _internal_logit_change();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TreeMetadata_PostPruneNodeUpdate::_internal_mutable_logit_change() {
  return &logit_change_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TreeMetadata_PostPruneNodeUpdate::mutable_logit_change() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate.logit_change)
  return _internal_mutable_logit_change();
}

// -------------------------------------------------------------------

// TreeMetadata

// int32 num_layers_grown = 2;
inline void TreeMetadata::clear_num_layers_grown() {
  num_layers_grown_ = 0;
}
inline int32_t TreeMetadata::_internal_num_layers_grown() const {
  return num_layers_grown_;
}
inline int32_t TreeMetadata::num_layers_grown() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeMetadata.num_layers_grown)
  return _internal_num_layers_grown();
}
inline void TreeMetadata::_internal_set_num_layers_grown(int32_t value) {
  
  num_layers_grown_ = value;
}
inline void TreeMetadata::set_num_layers_grown(int32_t value) {
  _internal_set_num_layers_grown(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.TreeMetadata.num_layers_grown)
}

// bool is_finalized = 3;
inline void TreeMetadata::clear_is_finalized() {
  is_finalized_ = false;
}
inline bool TreeMetadata::_internal_is_finalized() const {
  return is_finalized_;
}
inline bool TreeMetadata::is_finalized() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeMetadata.is_finalized)
  return _internal_is_finalized();
}
inline void TreeMetadata::_internal_set_is_finalized(bool value) {
  
  is_finalized_ = value;
}
inline void TreeMetadata::set_is_finalized(bool value) {
  _internal_set_is_finalized(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.TreeMetadata.is_finalized)
}

// repeated .tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate post_pruned_nodes_meta = 4;
inline int TreeMetadata::_internal_post_pruned_nodes_meta_size() const {
  return post_pruned_nodes_meta_.size();
}
inline int TreeMetadata::post_pruned_nodes_meta_size() const {
  return _internal_post_pruned_nodes_meta_size();
}
inline void TreeMetadata::clear_post_pruned_nodes_meta() {
  post_pruned_nodes_meta_.Clear();
}
inline ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* TreeMetadata::mutable_post_pruned_nodes_meta(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.TreeMetadata.post_pruned_nodes_meta)
  return post_pruned_nodes_meta_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate >*
TreeMetadata::mutable_post_pruned_nodes_meta() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.TreeMetadata.post_pruned_nodes_meta)
  return &post_pruned_nodes_meta_;
}
inline const ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate& TreeMetadata::_internal_post_pruned_nodes_meta(int index) const {
  return post_pruned_nodes_meta_.Get(index);
}
inline const ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate& TreeMetadata::post_pruned_nodes_meta(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeMetadata.post_pruned_nodes_meta)
  return _internal_post_pruned_nodes_meta(index);
}
inline ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* TreeMetadata::_internal_add_post_pruned_nodes_meta() {
  return post_pruned_nodes_meta_.Add();
}
inline ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* TreeMetadata::add_post_pruned_nodes_meta() {
  ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate* _add = _internal_add_post_pruned_nodes_meta();
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.TreeMetadata.post_pruned_nodes_meta)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata_PostPruneNodeUpdate >&
TreeMetadata::post_pruned_nodes_meta() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.TreeMetadata.post_pruned_nodes_meta)
  return post_pruned_nodes_meta_;
}

// -------------------------------------------------------------------

// GrowingMetadata

// int64 num_trees_attempted = 1;
inline void GrowingMetadata::clear_num_trees_attempted() {
  num_trees_attempted_ = int64_t{0};
}
inline int64_t GrowingMetadata::_internal_num_trees_attempted() const {
  return num_trees_attempted_;
}
inline int64_t GrowingMetadata::num_trees_attempted() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.GrowingMetadata.num_trees_attempted)
  return _internal_num_trees_attempted();
}
inline void GrowingMetadata::_internal_set_num_trees_attempted(int64_t value) {
  
  num_trees_attempted_ = value;
}
inline void GrowingMetadata::set_num_trees_attempted(int64_t value) {
  _internal_set_num_trees_attempted(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.GrowingMetadata.num_trees_attempted)
}

// int64 num_layers_attempted = 2;
inline void GrowingMetadata::clear_num_layers_attempted() {
  num_layers_attempted_ = int64_t{0};
}
inline int64_t GrowingMetadata::_internal_num_layers_attempted() const {
  return num_layers_attempted_;
}
inline int64_t GrowingMetadata::num_layers_attempted() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.GrowingMetadata.num_layers_attempted)
  return _internal_num_layers_attempted();
}
inline void GrowingMetadata::_internal_set_num_layers_attempted(int64_t value) {
  
  num_layers_attempted_ = value;
}
inline void GrowingMetadata::set_num_layers_attempted(int64_t value) {
  _internal_set_num_layers_attempted(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.GrowingMetadata.num_layers_attempted)
}

// int32 last_layer_node_start = 3;
inline void GrowingMetadata::clear_last_layer_node_start() {
  last_layer_node_start_ = 0;
}
inline int32_t GrowingMetadata::_internal_last_layer_node_start() const {
  return last_layer_node_start_;
}
inline int32_t GrowingMetadata::last_layer_node_start() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.GrowingMetadata.last_layer_node_start)
  return _internal_last_layer_node_start();
}
inline void GrowingMetadata::_internal_set_last_layer_node_start(int32_t value) {
  
  last_layer_node_start_ = value;
}
inline void GrowingMetadata::set_last_layer_node_start(int32_t value) {
  _internal_set_last_layer_node_start(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.GrowingMetadata.last_layer_node_start)
}

// int32 last_layer_node_end = 4;
inline void GrowingMetadata::clear_last_layer_node_end() {
  last_layer_node_end_ = 0;
}
inline int32_t GrowingMetadata::_internal_last_layer_node_end() const {
  return last_layer_node_end_;
}
inline int32_t GrowingMetadata::last_layer_node_end() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.GrowingMetadata.last_layer_node_end)
  return _internal_last_layer_node_end();
}
inline void GrowingMetadata::_internal_set_last_layer_node_end(int32_t value) {
  
  last_layer_node_end_ = value;
}
inline void GrowingMetadata::set_last_layer_node_end(int32_t value) {
  _internal_set_last_layer_node_end(value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.GrowingMetadata.last_layer_node_end)
}

// -------------------------------------------------------------------

// TreeEnsemble

// repeated .tensorflow.boosted_trees.Tree trees = 1;
inline int TreeEnsemble::_internal_trees_size() const {
  return trees_.size();
}
inline int TreeEnsemble::trees_size() const {
  return _internal_trees_size();
}
inline void TreeEnsemble::clear_trees() {
  trees_.Clear();
}
inline ::tensorflow::boosted_trees::Tree* TreeEnsemble::mutable_trees(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.TreeEnsemble.trees)
  return trees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Tree >*
TreeEnsemble::mutable_trees() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.TreeEnsemble.trees)
  return &trees_;
}
inline const ::tensorflow::boosted_trees::Tree& TreeEnsemble::_internal_trees(int index) const {
  return trees_.Get(index);
}
inline const ::tensorflow::boosted_trees::Tree& TreeEnsemble::trees(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeEnsemble.trees)
  return _internal_trees(index);
}
inline ::tensorflow::boosted_trees::Tree* TreeEnsemble::_internal_add_trees() {
  return trees_.Add();
}
inline ::tensorflow::boosted_trees::Tree* TreeEnsemble::add_trees() {
  ::tensorflow::boosted_trees::Tree* _add = _internal_add_trees();
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.TreeEnsemble.trees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::Tree >&
TreeEnsemble::trees() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.TreeEnsemble.trees)
  return trees_;
}

// repeated float tree_weights = 2;
inline int TreeEnsemble::_internal_tree_weights_size() const {
  return tree_weights_.size();
}
inline int TreeEnsemble::tree_weights_size() const {
  return _internal_tree_weights_size();
}
inline void TreeEnsemble::clear_tree_weights() {
  tree_weights_.Clear();
}
inline float TreeEnsemble::_internal_tree_weights(int index) const {
  return tree_weights_.Get(index);
}
inline float TreeEnsemble::tree_weights(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeEnsemble.tree_weights)
  return _internal_tree_weights(index);
}
inline void TreeEnsemble::set_tree_weights(int index, float value) {
  tree_weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.TreeEnsemble.tree_weights)
}
inline void TreeEnsemble::_internal_add_tree_weights(float value) {
  tree_weights_.Add(value);
}
inline void TreeEnsemble::add_tree_weights(float value) {
  _internal_add_tree_weights(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.TreeEnsemble.tree_weights)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TreeEnsemble::_internal_tree_weights() const {
  return tree_weights_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TreeEnsemble::tree_weights() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.TreeEnsemble.tree_weights)
  return _internal_tree_weights();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TreeEnsemble::_internal_mutable_tree_weights() {
  return &tree_weights_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TreeEnsemble::mutable_tree_weights() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.TreeEnsemble.tree_weights)
  return _internal_mutable_tree_weights();
}

// repeated .tensorflow.boosted_trees.TreeMetadata tree_metadata = 3;
inline int TreeEnsemble::_internal_tree_metadata_size() const {
  return tree_metadata_.size();
}
inline int TreeEnsemble::tree_metadata_size() const {
  return _internal_tree_metadata_size();
}
inline void TreeEnsemble::clear_tree_metadata() {
  tree_metadata_.Clear();
}
inline ::tensorflow::boosted_trees::TreeMetadata* TreeEnsemble::mutable_tree_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.TreeEnsemble.tree_metadata)
  return tree_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata >*
TreeEnsemble::mutable_tree_metadata() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.TreeEnsemble.tree_metadata)
  return &tree_metadata_;
}
inline const ::tensorflow::boosted_trees::TreeMetadata& TreeEnsemble::_internal_tree_metadata(int index) const {
  return tree_metadata_.Get(index);
}
inline const ::tensorflow::boosted_trees::TreeMetadata& TreeEnsemble::tree_metadata(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeEnsemble.tree_metadata)
  return _internal_tree_metadata(index);
}
inline ::tensorflow::boosted_trees::TreeMetadata* TreeEnsemble::_internal_add_tree_metadata() {
  return tree_metadata_.Add();
}
inline ::tensorflow::boosted_trees::TreeMetadata* TreeEnsemble::add_tree_metadata() {
  ::tensorflow::boosted_trees::TreeMetadata* _add = _internal_add_tree_metadata();
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.TreeEnsemble.tree_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::boosted_trees::TreeMetadata >&
TreeEnsemble::tree_metadata() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.TreeEnsemble.tree_metadata)
  return tree_metadata_;
}

// .tensorflow.boosted_trees.GrowingMetadata growing_metadata = 4;
inline bool TreeEnsemble::_internal_has_growing_metadata() const {
  return this != internal_default_instance() && growing_metadata_ != nullptr;
}
inline bool TreeEnsemble::has_growing_metadata() const {
  return _internal_has_growing_metadata();
}
inline void TreeEnsemble::clear_growing_metadata() {
  if (GetArenaForAllocation() == nullptr && growing_metadata_ != nullptr) {
    delete growing_metadata_;
  }
  growing_metadata_ = nullptr;
}
inline const ::tensorflow::boosted_trees::GrowingMetadata& TreeEnsemble::_internal_growing_metadata() const {
  const ::tensorflow::boosted_trees::GrowingMetadata* p = growing_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::boosted_trees::GrowingMetadata&>(
      ::tensorflow::boosted_trees::_GrowingMetadata_default_instance_);
}
inline const ::tensorflow::boosted_trees::GrowingMetadata& TreeEnsemble::growing_metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.TreeEnsemble.growing_metadata)
  return _internal_growing_metadata();
}
inline void TreeEnsemble::unsafe_arena_set_allocated_growing_metadata(
    ::tensorflow::boosted_trees::GrowingMetadata* growing_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(growing_metadata_);
  }
  growing_metadata_ = growing_metadata;
  if (growing_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.TreeEnsemble.growing_metadata)
}
inline ::tensorflow::boosted_trees::GrowingMetadata* TreeEnsemble::release_growing_metadata() {
  
  ::tensorflow::boosted_trees::GrowingMetadata* temp = growing_metadata_;
  growing_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::boosted_trees::GrowingMetadata* TreeEnsemble::unsafe_arena_release_growing_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.TreeEnsemble.growing_metadata)
  
  ::tensorflow::boosted_trees::GrowingMetadata* temp = growing_metadata_;
  growing_metadata_ = nullptr;
  return temp;
}
inline ::tensorflow::boosted_trees::GrowingMetadata* TreeEnsemble::_internal_mutable_growing_metadata() {
  
  if (growing_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::GrowingMetadata>(GetArenaForAllocation());
    growing_metadata_ = p;
  }
  return growing_metadata_;
}
inline ::tensorflow::boosted_trees::GrowingMetadata* TreeEnsemble::mutable_growing_metadata() {
  ::tensorflow::boosted_trees::GrowingMetadata* _msg = _internal_mutable_growing_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.TreeEnsemble.growing_metadata)
  return _msg;
}
inline void TreeEnsemble::set_allocated_growing_metadata(::tensorflow::boosted_trees::GrowingMetadata* growing_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete growing_metadata_;
  }
  if (growing_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tensorflow::boosted_trees::GrowingMetadata>::GetOwningArena(growing_metadata);
    if (message_arena != submessage_arena) {
      growing_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, growing_metadata, submessage_arena);
    }
    
  } else {
    
  }
  growing_metadata_ = growing_metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.TreeEnsemble.growing_metadata)
}

// -------------------------------------------------------------------

// DebugOutput

// repeated int32 feature_ids = 1;
inline int DebugOutput::_internal_feature_ids_size() const {
  return feature_ids_.size();
}
inline int DebugOutput::feature_ids_size() const {
  return _internal_feature_ids_size();
}
inline void DebugOutput::clear_feature_ids() {
  feature_ids_.Clear();
}
inline int32_t DebugOutput::_internal_feature_ids(int index) const {
  return feature_ids_.Get(index);
}
inline int32_t DebugOutput::feature_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DebugOutput.feature_ids)
  return _internal_feature_ids(index);
}
inline void DebugOutput::set_feature_ids(int index, int32_t value) {
  feature_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DebugOutput.feature_ids)
}
inline void DebugOutput::_internal_add_feature_ids(int32_t value) {
  feature_ids_.Add(value);
}
inline void DebugOutput::add_feature_ids(int32_t value) {
  _internal_add_feature_ids(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.DebugOutput.feature_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DebugOutput::_internal_feature_ids() const {
  return feature_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DebugOutput::feature_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.DebugOutput.feature_ids)
  return _internal_feature_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DebugOutput::_internal_mutable_feature_ids() {
  return &feature_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DebugOutput::mutable_feature_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.DebugOutput.feature_ids)
  return _internal_mutable_feature_ids();
}

// repeated float logits_path = 2;
inline int DebugOutput::_internal_logits_path_size() const {
  return logits_path_.size();
}
inline int DebugOutput::logits_path_size() const {
  return _internal_logits_path_size();
}
inline void DebugOutput::clear_logits_path() {
  logits_path_.Clear();
}
inline float DebugOutput::_internal_logits_path(int index) const {
  return logits_path_.Get(index);
}
inline float DebugOutput::logits_path(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DebugOutput.logits_path)
  return _internal_logits_path(index);
}
inline void DebugOutput::set_logits_path(int index, float value) {
  logits_path_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DebugOutput.logits_path)
}
inline void DebugOutput::_internal_add_logits_path(float value) {
  logits_path_.Add(value);
}
inline void DebugOutput::add_logits_path(float value) {
  _internal_add_logits_path(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.DebugOutput.logits_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DebugOutput::_internal_logits_path() const {
  return logits_path_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DebugOutput::logits_path() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.DebugOutput.logits_path)
  return _internal_logits_path();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DebugOutput::_internal_mutable_logits_path() {
  return &logits_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DebugOutput::mutable_logits_path() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.DebugOutput.logits_path)
  return _internal_mutable_logits_path();
}

// repeated int32 leaf_node_ids = 3;
inline int DebugOutput::_internal_leaf_node_ids_size() const {
  return leaf_node_ids_.size();
}
inline int DebugOutput::leaf_node_ids_size() const {
  return _internal_leaf_node_ids_size();
}
inline void DebugOutput::clear_leaf_node_ids() {
  leaf_node_ids_.Clear();
}
inline int32_t DebugOutput::_internal_leaf_node_ids(int index) const {
  return leaf_node_ids_.Get(index);
}
inline int32_t DebugOutput::leaf_node_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.DebugOutput.leaf_node_ids)
  return _internal_leaf_node_ids(index);
}
inline void DebugOutput::set_leaf_node_ids(int index, int32_t value) {
  leaf_node_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.DebugOutput.leaf_node_ids)
}
inline void DebugOutput::_internal_add_leaf_node_ids(int32_t value) {
  leaf_node_ids_.Add(value);
}
inline void DebugOutput::add_leaf_node_ids(int32_t value) {
  _internal_add_leaf_node_ids(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.DebugOutput.leaf_node_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DebugOutput::_internal_leaf_node_ids() const {
  return leaf_node_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DebugOutput::leaf_node_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.DebugOutput.leaf_node_ids)
  return _internal_leaf_node_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DebugOutput::_internal_mutable_leaf_node_ids() {
  return &leaf_node_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DebugOutput::mutable_leaf_node_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.DebugOutput.leaf_node_ids)
  return _internal_mutable_leaf_node_ids();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace boosted_trees
}  // namespace tensorflow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tensorflow::boosted_trees::SplitTypeWithDefault> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::SplitTypeWithDefault>() {
  return ::tensorflow::boosted_trees::SplitTypeWithDefault_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::boosted_trees::DefaultDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::DefaultDirection>() {
  return ::tensorflow::boosted_trees::DefaultDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fkernels_2fboosted_5ftrees_2fboosted_5ftrees_2eproto
