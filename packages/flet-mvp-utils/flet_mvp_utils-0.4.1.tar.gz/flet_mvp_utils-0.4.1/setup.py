# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['flet_mvp_utils']

package_data = \
{'': ['*']}

install_requires = \
['abstractcp>=0.9.9,<0.10.0',
 'flet-routed-app>=0.3.3,<0.4.0',
 'flet>=0.4.0,<0.5.0',
 'pydantic>=1.10.4,<2.0.0']

setup_kwargs = {
    'name': 'flet-mvp-utils',
    'version': '0.4.1',
    'description': 'Tools to build flet apps with the MVP architecture pattern',
    'long_description': '# flet-mvp-utils\n\n- [flet-mvp-utils](#flet-mvp-utils)\n  - [Architecture / API](#architecture--api)\n  - [Usage](#usage)\n    - [View](#view)\n    - [Presenter](#presenter)\n    - [DataSource](#datasource)\n    - [Model](#model)\n    - [Validation / error handling](#validation--error-handling)\n\nThis library provides tools that make it a bit easier\nto follow architecture patterns in your flet app\nthat leverage on immutable models and unidirectional control flow.\nThose are mostly based on the Model-View-Presenter/MVP pattern,\nhence the name of the library.\nAt this stage,\nit can be used to ease working with any model-based architecture pattern though.\n\n## Architecture / API\n\n```mermaid\nflowchart TB\n    View-- "intent methods call handlers"-->Presenter\n    Presenter-- pass new model to render-->View\n    Presenter-- handle intent concretely -->DataSource\n    DataSource-- notify of new model -->Presenter\n    DataSource-- create from intended/resulting changes -->Model\n    DataSource<-- query/modify according to intent -->DB/API/etc\n```\n\nOne of the main goals of this library\nis to reduce the amount of boilerplate code that is needed\nin order to implement an MVP-based architecture for flet apps.\nThis should however not come at the cost of typechecking and autocomplete.\nThat is why for each class you will interact with,\nthe general way of doing things stays the same:\n\n```python\nclass MyClass(LibraryClass):\n    variable_needed_by_library_class_and_this_class: MyOtherClass\n\n    def some_method(self):\n        ...\n```\n\nThis approach solves the following problem:\nIn order to do their helpful work behind the scenes,\nthe library classes need to access objects\nthat the concrete subclasses receive or create,\ne.g. the DataSource in MvpPresenter implementations.\nMvpPresenter can only know that the DataSource is an instance of MvpDataSource,\nso a subclass accessing a `self.data_source` variable set in the parent class\n(how it is set is more or less irrelevant) would not know anymore than that\nand thus your IDE can\'t properly autocomplete for you anymore.\n\nThere is a bit of magic\n(namely abstract class properties and a bit of dataclass wizardry)\ngoing on behind the scenes that makes this work,\nbut it should save you from ever having to write an `__init__()` method\nwhile still getting helpful autocomplete in `MyClass` for\n`variable_needed_by_library_class_and_this_class`.\nIt also makes the approach more declarative rather than imperative,\nwhich some developers might prefer (or so I\'ve heard).\n\nIf you feel you need this library to properly design your flet app,\nit is probably complex enough to need routing\nand maybe even an app state solution as well.\nLucky for you, [flet-routed-app](https://github.com/iron3oxide/flet-routed-app)\nand flet-mvp-utils are designed to compliment each other\nwhile none of both strictly requires usage of the other in order to work.\n\n## Usage\n\nSay you have a form and want to validate the TextFields in it\nwhen a submit button is clicked.\n\n### View\n\nYour view uses [refs](https://flet.dev/docs/guides/python/control-refs/).\nThe actual UI code may be located somewhere else\nand simply receive the refs and/or callbacks\nand return a component that is connected to the ref.\nWhen creating the view class, you inherit from `MvpView`\nand create a class variable named `ref_map`,\ncontaining a dictionary that maps the attribute names\nof your model to the respective ref\nof the control that should be tied to it.\nAny variable intended for the `flet.View` constructor will be accepted\nand passed on by the default `__init__()` method,\nso you don\'t need to define your own in most cases.\n\n```python\nimport flet as ft\n\nfrom flet_mvp_utils import MvpView\n\n\nclass FormView(MvpView):\n    ref_map = {\n            "last_name": ft.Ref[ft.TextField](),\n            "first_name": ft.Ref[ft.TextField](),\n            "age": ft.Ref[ft.TextField](),\n        }\n\n    def some_intent_method(self, e) -> None:\n        ...\n```\n\n`MvpView` has a `render(model)` method that takes a model\nand updates any refs\' current value to the model value if they aren\'t the same.\nThis method is supposed to be called in the callback\nyou register with the DataSource,\nso that a changed model is immediately reflected in the view.\nAs you will learn in the next section,\nthis doesn\'t have to concern you as it can be done automatically.\n\n### Presenter\n\nAny class that inherits from `MvpPresenter` updates the view automatically\nonce it is notified of a model update.\n`MvpPresenter` is a dataclass\nand so should its subclasses be.\nThis helps to reduce the amount of boilerplate code\n(specifically `__init__()` methods) you have to write\nand keeps the general API of this library consistent.\nSince both the DataSource and the View are known to it\n(because the subclass fields override the fields of the same name in the superclass),\n`MvpPresenter` will automatically register a method as a callback with the DataSource\nthat renders the new model in the given view in its `__post_init__()` hook.\n\n```python\nfrom dataclasses import dataclass\nfrom flet_mvp_utils import MvpPresenter\n\nfrom my_package.views.form import FormDataSource, FormViewProtocol\n\n\n@dataclass\nclass FormPresenter(MvpPresenter):\n    data_source: FormDataSource\n    view: FormViewProtocol\n\n    def some_intent_handling_method(self) -> None:\n        ...\n```\n\n`MvpPresenter` also provides a generic `build()` method\nthat simply calls the `build(presenter)` method of the view\nwith itself as the sole argument.\nIf you need a custom build method for your presenter,\njust override it with your own.\n\n### DataSource\n\nThe DataSource class, inheriting from `MvpDataSource`,\nis where the business logic of your component/virtual page will live.\nSince the latter inherits from `Observable`,\nbrokers of any kind (presenter classes in MVP-based architectures)\ncan register callback functions with your DataSource class\nthat will be executed when you call `self.notify_observers()` in it.\nAs mentioned above, subclasses of `MvpPresenter` do this for you automatically\nafter you initialized them properly.\n\nThese callbacks are meant to be used to inform a presenter that a new,\nupdated model has been created.\nSince creating new models to replace the current one is a rather repetitive\nand uniform task,\n`MvpDataSource` will do it for you.\nAll you have to do is pass your model class to its constructor\nand call `self.update_model_partial(changes: dict)`\nor `self.update_model_complete(new_model: dict)` depending on your use case.\n\n```python\nfrom flet_mvp_utils import MvpDataSource\n\n\nclass FormDataSource(MvpDataSource):\n    current_model = FormModel()\n\n    def some_method(self) -> None:\n        ...\n```\n\nYou will also see that after intitializing the superclass,\nyour DataSource will have a `self.current_model` attribute.\nWhile you can be sure that this is a pydantic BaseModel,\nit is typed as `Any` to avoid typechecking troubles.\n\n### Model\n\nThe model is supposed to act as the state of your view.\nIt should contain everything the view needs to know\nin order to render/update itself.\nThis can be data from a database, an API,\na config file or even just another component.\n\nYour model inherits from `MvpModel`,\nwhich is an immutable pydantic BaseModel.\nThis means you can write custom validators for each attribute\nand validate all your data whenever a new instance of the model is created.\n\nThe model is immutable to force good habits upon the ones using it.\nGood habits in this context means not to modify your current model anywhere\nbut in your DataSource class as that should be the single source of truth.\nOf course immutability is never enforced 100% in python,\nbut this should suffice.\n\n```python\nfrom flet_mvp_utils import MvpModel\n\n\nclass FormModel(MvpModel):\n    last_name: str = ""\n    first_name: str = ""\n    age: int = 0\n```\n\n### Validation / error handling\n\nNotice that `age` is an `int`,\neven though the ref we assigned to it earlier points to a TextField?\nThat\'s no problem at all,\nyou\'ll have to do no manual conversion.\nPydantic will parse the text input into an `int`\nand raise an error if that fails.\nWe probably want to inform our user though that they have input invalid data.\nTo do this, we\'ll simply typehint `age` differently.\n\n```python\nfrom flet_mvp_utils import ErrorMessage, MvpModel\n\n\nclass FormModel(MvpModel):\n    last_name: str = ""\n    first_name: str = ""\n    age: ErrorMessage | int = 0\n```\n\n> It\'s important to specify the narrower type (ErrorMessage) first,\n> otherwise every error message would just say\n> that the field is not an instance of ErrorMessage.\n\nThis is where the magic of the update_model methods of `MvpDataSource` comes to light.\nIf the creation of a new model fails,\ne.g. because a user put "old" into the age TextField instead of a number,\nour DataSource will now catch this error,\nwrap its message in an `ErrorMessage` object\nand assign it to the age field\nof a new model that contains all changes,\nboth the valid inputs and the error mesages.\nMultiple errors at once are no problem at all,\neach ErrorMessage will be assigned to the field that caused it.\n\nSince we probably don\'t want to make any calls to a database, API etc. in that case,\nthe update_model methods will return a bool\nto let you know if there was an error.\n\nThe subscribed observers will be notified either way\nand the model will thus be rendered.\n`MvpView.render()` will try to assign fields that are instances of `ErrorMessage`\nto the `error_text` property of the control that the associated ref points to.\nThis means that you should only use this technique for model fields\nthat are associated with controls that actually have that property,\nlike TextField or Dropdown.\n',
    'author': 'iron3oxide',
    'author_email': 'jason.hottelet@tuta.io',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
