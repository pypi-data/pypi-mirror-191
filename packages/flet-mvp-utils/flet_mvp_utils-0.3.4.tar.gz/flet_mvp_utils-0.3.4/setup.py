# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['flet_mvp_utils']

package_data = \
{'': ['*']}

install_requires = \
['flet>=0.4.0,<0.5.0', 'pydantic>=1.10.4,<2.0.0']

setup_kwargs = {
    'name': 'flet-mvp-utils',
    'version': '0.3.4',
    'description': 'Tools to build flet apps with the MVP architecture pattern',
    'long_description': '# flet-mvp-utils\n\n- [flet-mvp-utils](#flet-mvp-utils)\n  - [Architecture](#architecture)\n  - [Usage](#usage)\n    - [View](#view)\n    - [Presenter](#presenter)\n    - [DataSource](#datasource)\n    - [Model](#model)\n    - [Validation / error handling](#validation--error-handling)\n\nThis library provides tools that make it a bit easier\nto follow architecture patterns in your flet app\nthat leverage on immutable models and unidirectional control flow.\nThose are mostly based on the Model-View-Presenter/MVP pattern,\nhence the name of the library.\nAt this stage,\nit can be used to ease working with any model-based architecture pattern though.\n\n## Architecture\n\n```mermaid\nflowchart TB\n    View-- "intent methods call handlers"-->Presenter\n    Presenter-- pass new model to render-->View\n    Presenter-- handle intent concretely -->DataSource\n    DataSource-- notify of new model -->Presenter\n    DataSource-- create from intended/resulting changes -->Model\n    DataSource<-- query/modify according to intent -->DB/API/etc\n```\n\n## Usage\n\nSay you have a form and want to validate the TextFields in it\nwhen a submit button is clicked.\n\n### View\n\nYour view uses [refs](https://flet.dev/docs/guides/python/control-refs/).\nThe actual UI code may be located somewhere else\nand simply receive the refs and return a component that is connected to the ref.\nWhen creating the view class, you inherit from `MvpView`\nand in your `__init__.py`, you create a dictionary that maps the attribute names\nof your model to the respective ref\nof the control that should be tied to it.\nYou then pass this dictionary to `super().__init__()`,\nalong with any variable intended for the `flet.View` constructor.\n\n```python\nimport flet as ft\n\nfrom flet_mvp_utils import MvpView\n\n\nclass FormView(MvpView):\n    def __init__(self, route: str)\n        self.ref_map = {\n            "last_name": ft.Ref[ft.TextField](),\n            "first_name": ft.Ref[ft.TextField](),\n            "age": ft.Ref[ft.TextField](),\n        }\n        super().__init__(\n            ref_map=self.ref_map,\n            route=route\n        )\n\n```\n\n`MvpView` has a `render(model)` method that takes a model\nand updates any refs\' current value to the model value if they aren\'t the same.\nThis method is supposed to be called in the callback\nyou register with the DataSource,\nso that a changed model is immediately reflected in the view.\n\n### Presenter\n\nAny class that inherits from `MvpPresenter` updates the view automatically\nonce it is notified of a model update.\nSince it will be given both the View and the DataSource upon creation,\nit can easily do this in its `__init__()` method.\n\n```python\nfrom flet_mvp_utils import MvpPresenter\n\n\nclass FormPresenter(MvpPresenter):\n    def __init__(self, data_source: FormDataSource, view: FormViewProtocol):\n        self.data_source = data_source\n        self.view = view\n\n        super().__init__(self.data_source, self.view)\n```\n\n`MvpPresenter` also provides a generic `build()` method\nthat simply calls the `build(presenter)` method of the view\nwith itself as the sole argument.\nIf you need a custom build method for your presenter,\njust override it with your own.\n\n### DataSource\n\nThe DataSource class, inheriting from `MvpDataSource`,\nis where the business logic of your component/virtual page will live.\nSince the latter inherits from `Observable`,\nbrokers of any kind (presenter classes in MVP-based architectures)\ncan register callback functions with your DataSource class\nthat will be executed when you call `self.notify_observers()` in it.\nAs mentioned above, subclasses of `MvpPresenter` do this for you automatically\nafter you initialized them properly.\n\nThese callbacks are meant to be used to inform a presenter that a new,\nupdated model has been created.\nSince creating and updating a model is a rather repetitive and uniform task,\n`MvpDataSource` will do it for you.\nAll you have to do is pass your model class to its constructor\nand call `self.update_model_partial(changes: dict)`\nor `self.update_model_complete(new_model: dict)` depending on your use case.\n\n```python\nfrom flet_mvp_utils import MvpDataSource\n\n\nclass FormDataSource(MvpDataSource):\n    def __init__(self, ...):\n        super().__init__(FormModel)\n```\n\nYou will also see that after intitializing the superclass,\nyour DataSource will have a `self.current_model` attribute.\nWhile you can be sure that this is a pydantic BaseModel,\nit is typed as `Any` to avoid typechecking troubles.\n\n### Model\n\nThe model is supposed to act as the state of your view.\nIt should contain everything the view needs to know\nin order to render/update itself.\nThis can be data from a database, an API,\na config file or even just another component.\n\nYour model inherits from `MvpModel`,\nwhich is an immutable pydantic BaseModel.\nThis means you can write custom validators for each attribute\nand validate all your data whenever a new instance of the model is created.\n\nThe model is immutable to force good habits upon the ones using it.\nGood habits in this context means not to modify your current model anywhere\nbut in your DataSource class as that should be the single source of truth.\nOf course immutability is never enforced 100% in python,\nbut this should suffice.\n\n```python\nfrom flet_mvp_utils import MvpModel\n\n\nclass FormModel(MvpModel):\n    last_name: str = ""\n    first_name: str = ""\n    age: int = 0\n```\n\n### Validation / error handling\n\nNotice that `age` is an `int`,\neven though the ref we assigned to it earlier points to a TextField?\nThat\'s no problem at all,\nyou\'ll have to do no manual conversion.\nPydantic will parse the text input into an `int`\nand raise an error if that fails.\nWe probably want to inform our user though that they have input invalid data.\nTo do this, we\'ll simply typehint `age` differently.\n\n```python\nfrom flet_mvp_utils import ErrorMessage, MvpModel\n\n\nclass FormModel(MvpModel):\n    last_name: str = ""\n    first_name: str = ""\n    age: ErrorMessage | int = 0\n```\n\n> It\'s important to specify the narrower type (ErrorMessage) first,\n> otherwise every error message would just say\n> that the field is not an instance of ErrorMessage.\n\nThis is where the magic of the update_model methods of `MvpDataSource` comes to light.\nIf the creation of a new model fails,\ne.g. because a user put "old" into the age TextField instead of a number,\nour DataSource will now catch this error,\nwrap its message in an `ErrorMessage` object\nand assign it to the age field\nof a new model that contains all changes,\nboth the valid inputs and the error mesages.\nMultiple errors at once are no problem at all,\neach ErrorMessage will be assigned to the field that caused it.\n\nSince we probably don\'t want to make any calls to a database, API etc. in that case,\nthe update_model methods will return a bool\nto let you know if there was an error.\n\nThe subscribed observers will be notified either way\nand the model will thus be rendered.\n`MvpView.render()` will try to assign fields that are instances of `ErrorMessage`\nto the `error_text` property of the control that the associated ref points to.\nThis means that you should only use this technique for model fields\nthat are associated with controls that actually have that property,\nlike TextField or Dropdown.\n',
    'author': 'iron3oxide',
    'author_email': 'jason.hottelet@tuta.io',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
