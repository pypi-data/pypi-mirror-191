# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['flet_routed_app']

package_data = \
{'': ['*']}

install_requires = \
['flet>=0.4.0,<0.5.0', 'repath>=0.9.0,<0.10.0']

setup_kwargs = {
    'name': 'flet-routed-app',
    'version': '0.3.4',
    'description': 'Tools to build flet apps with multiple views/routes',
    'long_description': '# Flet Routed App\n\n- [Flet Routed App](#flet-routed-app)\n  - [When will I need this?](#when-will-i-need-this)\n  - [How do I use this?](#how-do-i-use-this)\n    - [ViewBuilder class](#viewbuilder-class)\n    - [Route assignment](#route-assignment)\n    - [Route protection](#route-protection)\n    - [Aggregating ViewBuilder classes](#aggregating-viewbuilder-classes)\n    - [RoutedApp usage](#routedapp-usage)\n    - [App state](#app-state)\n\n## When will I need this?\n\nSay you want to design an app for a government agency with multiple,\nlet\'s say 20+ pages (MPA = Multi Page Application).\nSince Flet is technically SPA (Single Page Application) only,\nyou\'ll use views and some routing to simulate the MPA behaviour.\n\nNot every person in the agency should be able to access every page/view.\nAlso, they shouldn\'t be able to see anything\nbut the login page until they\'re logged in.\nThe roles defined in the OAuth token the app receives upon login\nwill determine what pages/views a user has access to.\n\nYou\'ll probably want to design your app in a way that bundles every page/view\ninto its own module.\nIf you used an architecture design pattern\n(which you definitely should at this scale),\nobtaining the view requires building its model\nand presenter or controller as well\nand thus you need some function or method to obtain the view.\n\nThe way flet routing works ATM,\na view will have to be recreated after a route change,\nso you\'ll want to match each route of your app\nto the function or method that creates the appropriate view for it.\nYou\'ll also want the function/method to return a different view\nor raise an exception if the user is not authorized to access it.\nThis can create a lot of boilerplate code\nif you don\'t have the help of a library.\n\n## How do I use this?\n\n### ViewBuilder class\n\nIn the module of your page/view,\ncreate a file called (something like) `build.py`.\nIn it, create a class called (something like) `{page_name}ViewBuilder`.\nThis class should inherit from the `ViewBuilder` class of this library\nand at minimum define a method with the signature\n\n```python\ndef build_view(self, route_parameters: dict[str, str]) -> flet.View\n```\n\nThis library also contains convenience ViewBuilder subclasses\nthat provide a shortcut for common architecture design patterns.\nThe MvpViewBuilder for example only requires you to define three class variables:\n\n```python\nfrom flet_routed_app import MvpViewBuilder\n\nfrom my_package.views.counter import CounterDataSource, CounterPresenter, CounterView\n\n\nclass CounterViewBuilder(MvpViewBuilder):\n    data_source_class = CounterDataSource\n    presenter_class = CounterPresenter\n    view_class = CounterView\n```\n\n### Route assignment\n\n```python\nfrom flet_routed_app import MvpViewBuilder, route\n\nfrom my_package.views.counter import CounterDataSource, CounterPresenter, CounterView\n\n@route("/counter")\nclass CounterViewBuilder(MvpViewBuilder):\n    data_source_class = CounterDataSource\n    presenter_class = CounterPresenter\n    view_class = CounterView\n```\n\n### Route protection\n\n```python\nfrom flet_routed_app import MvpViewBuilder, login_required, route\n\nfrom my_package.views.counter import CounterDataSource, CounterPresenter, CounterView\n\n@login_required\n@route("/counter")\nclass CounterViewBuilder(MvpViewBuilder):\n    data_source_class = CounterDataSource\n    presenter_class = CounterPresenter\n    view_class = CounterView\n```\n\n```python\nfrom flet_routed_app import MvpViewBuilder, group_required, route\n\nfrom my_package.views.counter import CounterDataSource, CounterPresenter, CounterView\n\n@group_required("demo")\n@route("/counter")\nclass CounterViewBuilder(MvpViewBuilder):\n    data_source_class = CounterDataSource\n    presenter_class = CounterPresenter\n    view_class = CounterView\n```\n\nYou can also easily write your own auth decorator,\nall it has to do is define a function that returns a bool\nand set the `auth_func` attribute\nof the ViewBuilder class it wraps to that function.\n\n### Aggregating ViewBuilder classes\n\nSomewhere in your project, you will have to import all ViewBuilder classes\nand aggregate them in a list.\nThe recommended approach is to do this in the `__init__.py`\nof the module that contains all your view modules.\n\nIt is also possible to create multiple lists\nof different ViewBuilders in different places in your project\nand to then add these lists to the app one after another.\n\n### RoutedApp usage\n\nIn your main() function,\ncreate an instance of RoutedApp\nand add the previously imported list of ViewBuilder classes to the instance.\n\n```python\nimport flet as ft\n\nfrom flet_routed_app import RoutedApp\n\nfrom mypackage import views\n\ndef main(page: ft.Page):\n    app = RoutedApp(page)\n    app.add_view_builders(views.view_builders)\n\nft.app(target=main)\n```\n\n### App state\n\nYou can share data between different pages/views\nby storing it in the `state` dictionary of the app instance\nand retrieving it from there.\n\n`state` is a defaultdict;\nif a key does not exist,\nit will return the string Literal "not set".\n\nEach ViewBuilder will be passed the app instance\nwhen it is added to that very instance.\n\nIf you know exactly which variables you will need to pass at runtime\nand you want to have autocomplete in your editor,\nyou can create custom app and state classes in an `app.py` file like this:\n\n```python\nfrom flet_routed_app import CustomAppState, RoutedApp\n\n\nclass AppState(CustomAppState):\n    test: int = 0\n    demo: str = ""\n\n\nclass App(RoutedApp):\n    state: AppState = AppState()\n```\n\nPlease remember to use those throughout your project when typehinting,\notherwise you won\'t reap the autocomplete benefits.\n\n`CustomAppState` is an empty dataclass which saves you the trouble\nof having to import dataclasses and decorate your class\nand ensures better type safety for the library.\n\nYou will also need to pass the `custom_state=True` flag\nwhen creating the app instance,\nso the constructor  of `RoutedApp` knows not to set the `state` class variable\nto an empty defaultdict.\n',
    'author': 'iron3oxide',
    'author_email': 'jason.hottelet@tuta.io',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/iron3oxide/flet-routed-app',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
